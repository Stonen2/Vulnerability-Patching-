<?php
//Created by Nick Stone 
//Secure progamming to parse user input to detect and defend SQL injection XSS and JS injection


//echo 'Hello World'; 
//For now we are just going to print the string to the page to get used to php
/*The function is desigened to take in a string that is going to be parsed as a means to mitigate and stop Cross Site scripting as well as javascript injection This is done by first
Looping through a given string and parsing out with regular expression a series of known special characters. Once this is done an array is populated with known HTML and Javascript
Commands that are then run through a permutation function which returns all of the possible permutations of a given String. From this these are then padded with / in order to run 
Regular expressions against in PHP and then parsed against the input string Replacing all commands that would be invoked by HTML or JS with ""
*/
function javascriptparse($String_To_Parse){
    //Parse some evil stuff right off the bat 
    //$String_To_Parse = preg_replace('/@///%/^/&/*/</>//:/;/]', '',$String_To_Parse); 
    //[@,#,$,%,^,&,*,<,>,/,',:,;']
    //$String_To_Parse = preg_replace('///', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/@/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/#/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/$/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/%/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/^/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/&/', '',$String_To_Parse); 
   // $String_To_Parse = preg_replace('/*/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/</', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/>/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace("/'/", '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/:/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/;/','',$String_To_Parse); 
    //$String_To_Parse = preg_replace('///','',$String_To_Parse); 
    //Make and populate an array with every possible Tag that could be used to hurt us'
    $tags = array(); 
    array_push($tags, 'html', 'head', 'body', 'frameset', 'script', 'noscript', 'style', 'meta', 'link', 'title', 'frame',
    'noframes', 'section', 'nav', 'aside', 'hgroup', 'header', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
     'pre', 'div', 'blockquote', 'hr', 'address', 'figure', 'figcaption', 'form', 'fieldset', 
    'del', 'dl', 'dt', 'dd', 'table', 'caption', 'thead', 'tfoot', 'tbody', 'colgroup', 'col',
    'td', 'video', 'audio', 'canvas', 'details',  'plaintext', 'template', 'article', 
    'svg', 'object', 'base', 'font', 'tt', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd',
    'var', 'cite', 'abbr', 'time', 'acronym', 'mark', 'ruby', 'rt', 'rp',  'img',  'wbr', 'map',
    'sub', 'sup', 'bdo', 'iframe', 'embed', 'span', 'input', 'select', 'textarea', 'label', 'button', 'optgroup',
    'option', 'legend', 'datalist', 'keygen', 'output', 'progress', 'meter', 'area', 'param', 'source', 'track',
    'summary', 'command', 'device', 'area', 'basefont', 'bgsound', 'menuitem', 'param', 'source', 'track',
    'data', 'bdi','meta', 'link', 'base', 'frame', 'img', 'wbr', 'embed', 'hr', 'input', 'keygen', 'command',
    'device', 'area', 'basefont', 'bgsound', 'menuitem', 'param', 'source', 'track', 'input', 'keygen', 'object', 'select', 'textarea');

//Lets set up the parsing now 

foreach($tags as $Tag_parse){

    //echo $String_To_Parse; 
    $Holdup = array(); 
    $Holdup = permutations($Tag_parse); 
    //Loop through each of the words that have been generated in the permutations
    foreach($Holdup as $Newpermut)
    {
        //Need to pad with the / characters for php to run the regular expression against
        $tos = '/'; 
        $tos .= $Newpermut; 
        $tos .= '/'; 
    
    //echo $Newpermut; 
    //Regular expression to remove the generated chatacters if in the string
    $String_To_Parse = preg_replace($tos, '',$String_To_Parse); 
    
    }
    // echo 'This is a test of a function call'; 

    }



    // echo $Holdup[1]; 
    /*
    Following code is example code for PHP regular expression find and replace!
$string = 'The quick brown fox jumps over the lazy dog.';
$patterns = array();
$patterns[0] = '/quick/';
$patterns[1] = '/brown/';
$patterns[2] = '/fox/';
$replacements = array();
$replacements[2] = 'bear';
$replacements[1] = 'black';
$replacements[0] = 'slow';
echo preg_replace($patterns, $replacements, $string);   
preg_replace(RegularExpression, Replacement Text, String to parse)
    */

    //Return the given String
    return $String_To_Parse; 

}
/*The purpose of this function is to take in a given String and return all possible permutations of how the word could be entered in an array. For example suppose the String abc.Some
Web servers will execute all JS SQL Inject commands even if weird or abnormal capitilization is placed on a given String. So given the example abc the following Strings would be put
into an array and would be returned to the calling function. 
abc,Abc,aBc,abC,ABc,AbC,aBC,ABC.
*/
function permutations($input) 
{ 
     //We need to cast the string to be lowercase This is our base case
    $input = strtolower($input);  
    //Create a new array to hold all of the values
    $permutation_Array = array();   
    //Need to loop through so we need to gather the number of characters in the string
    $length = strlen($input);  
    //We know Length^2 number of permutations
    $max = pow(2,$length); 
    //Set a counter to loop with 
    $i = 0; 
    //Set a loop to loop through all of the possible combinations
    while($i < $max){
        //Combination is equal to the lowercase value of the input 
        $combination = $input; 
        //Set a j counter
        $j = 0; 
        //Loop through to find each of the permuations of this string
        while ($j < $length){
            //Bit Shift with a bitwise AND operation to determine which characters will be uppercase
            if((($i >> $j) & 1) == 1){
              //Change the character to be upper case
              $combination[$j] = chr(ord($combination[$j]) - 32); 
            }  
            $j++; 
        } 
        //push the new word with the upper case values onto the array and do it again
        array_push($permutation_Array,$combination); 
        //Increment I
        $i++; 
        //Jump back up to the loop and do it again 
        continue; 
    } 
    //Return the array that contains all of the possible permutations
    return $permutation_Array; 

} 



/*The purpose of this function is to take in a string that will be enetered into some form of query. the purpose of this is to sanitize the input as to mitigate and stop SQL injection
attacks by going through a string and first parsing out a series of unwanted characters... These being special characters. Then the program will loop through a pre-generated array of 
known sql commands and will run through each permutation of the word before generating a regular expression to parse out each of the permutated words that have been generated. */ 
function SqlInjectionParse($String_To_Parse){


    //Create an array and push all of the SQL short codes into the array 
    $tags = array();
    //The following lines of code parse out unwanted and particularly special characters that should not be included in most user Strings
    $String_To_Parse = preg_replace('/@/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/#/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/$/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/%/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/^/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/&/', '',$String_To_Parse); 
   // $String_To_Parse = preg_replace('/*/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/</', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/>/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace("/'/", '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/:/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/;/','',$String_To_Parse); 
    //Push some known sql commands onto the array for us to permutate and then use to remove these words from the string
    array_push($tags,'select','union', 'where', 'or', 'and', 'group', 'schema', 'table', 'alter', 'as', 'avg','between',
    'case','count','create','delete','group','by', 'having','inner','join','outer','insert','null',
    'like','limit', 'distinct', 'update','with','from');


    //Loop through each word in the array 
    foreach($tags as $Tag_parse){


        //echo $String_To_Parse; 
        //Create a new array
        $Holdup = array(); 
        //Cast the new array to hold all of the possible permutations of the word in question
        $Holdup = permutations($Tag_parse); 
        //Loop Through each of the permutations
        foreach($Holdup as $Newpermut)
        {
            //Pad the word with / in order to run regular expressions against
            $tos = '/'; 
            $tos .= $Newpermut; 
            $tos .= '/'; 
        
        //echo $Newpermut; 
        //Replace each of the found permutations with "" 
        $String_To_Parse = preg_replace($tos, '',$String_To_Parse); 
      //  echo $String_To_Parse; 
        }
        // echo 'This is a test of a function call'; 
    
    }
    //Return the sanitized input
    return $String_To_Parse; 


}



/*This function is designed to update every users password hash in the users databse in a given web database. This is done by first establishing a connection to the database
Then the program gets the total number of users in the database to then create a loop to go through each user, track its username assuming username is the primary key as well 
as update the password by sending the password through a SHA 256. This could lead to a double hash however this is not a problem. This then inserts the new password back into 
the database on a given primary key assuming username is the primary key. The program has error handling to tell the program if a record failed or was successfully updated. 
The error handling does inform the user which user failed to be updated. 
*/
function hashupdate(){
    //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
    $servername = "localhost";
    $username = "*****";
    $password = "******";
    $dbname = "******";

    //Start a connection with the database
    $conn = new mysqli($servername, $username, $password, $dbname);
    //Write a Query to gather all users from the database including passwords
    $query  = "SELECT username, passwd FROM users";
    //Execute the query
    $results = $conn -> query($query);
    //Get the total number of results in the query (Num users) 
    $numusers = $results -> fetch_row(); 
    $z = 0; 
    $b = 1; 
//Create a loop to update every user in the database
    for($i = 0; $i < $numusers; $i++){
        //Username is stored at position 0
        $username = $results[$z]; 
        //PAssword given at position 1
        $pass = $results[$b];
        //Update the hash on the password
        $pass = hash('sha256', $pass);
        //Now update the given record with the new SHA 256 pass Assumes Username is primary key 
        $q = "UPDATE users
            SET passwd = '$pass'
            WHERE username = '$username'
            ";
        //Next set of users 
        $b++;
        $b++; 
        $z++; 
        $z++;
        //If the query was succesful
        if ($conn->query($q) === TRUE) 
        {
            //Print success to the screen
            echo "Record updated successfully \n";
        } 
        else 
        {
            //query failed print the error and the username of the offending tuple
            echo "Error updating record: " . $conn->error;
            echo " \n The record that failed to upload properly is " . $username;  
        }
    }


}
/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (MD5) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
function newauthMD5($String_To_Auth,$User){
    //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
    $servername = "localhost";
    $username = "*****";
    $password = "******";
    $dbname = "******";

    //Start a connection with the database
    $conn = new mysqli($servername, $username, $password, $dbname);
    //Write a query that is designed to get the hash value of a usernames password
    $q = "SELECT pass from users where username = '$user'"; 
    //Execute the query
    $results = $conn -> query($q); 
    //Get the results from thr query
    $passhash = $results[0]; 
    //Hash the first time in the original hash assuming md5
    $hashpass = hash('md5',$String_To_Auth); 
    //Hash on the new hash that we gave, IE sha 256
    $hashpass = hash('sha256',$hashpass); 

    //If they are equal its the same pass
    if($hashpass === $passhash){
        return TRUE; 
    }
    //Else it is not
    return FALSE; 

}
/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (SHA 1) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
function newauthSHA1($String_To_Auth,$user){
  //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
  $servername = "localhost";
  $username = "*****";
  $password = "******";
  $dbname = "******";

  //Start a connection with the database
  $conn = new mysqli($servername, $username, $password, $dbname);
  //Write a query that is designed to get the hash value of a usernames password
  $q = "SELECT pass from users where username = '$user'"; 
  //Get the results from the query 
  $results = $conn -> query($q); 
  //Store the password hash that is in the database
  $passhash = $results[0]; 
  
  //First hash on sha1 (legacy)
  $hashpass = hash('sha1',$String_To_Auth); 
  //Rehash on our new updated hash IE sha 256 
  $hashpass = hash('sha256',$hashpass); 
  //If the new generated hash is equal to the stored DB hash then we authenticate
  if($hashpass === $passhash){
      return TRUE; 
  }
  //Else we return false
  return FALSE; 



}


//this function is to be used if an individual email is sent out for users to create a new password for authentication purposes
/*This function is designed to update every users password hash in the users databse in a given web database. This is done by first establishing a connection to the database
Then the program gets the total number of users in the database to then create a loop to go through each user, track its username assuming username is the primary key as well 
as update the password by sending the password through a SHA 256. This could lead to a double hash however this is not a problem. This then inserts the new password back into 
the database on a given primary key assuming username is the primary key. The program has error handling to tell the program if a record failed or was successfully updated. 
The error handling does inform the user which user failed to be updated. 
*/
function hashupdateemail($PassToStore,$User){
    //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
    $servername = "localhost";
    $username = "*****";
    $password = "******";
    $dbname = "******";
    //Start a connection with the database
    $conn = new mysqli($servername, $username, $password, $dbname);
        //Update the hash on the password
        $PassToStore= hash('sha256', $PassToStore);
        //Now update the given record with the new SHA 256 pass Assumes Username is primary key 
        $q = "UPDATE users
            SET passwd = '$PassToStore'
            WHERE username = '$User'
            ";
        //If the query was succesful
        if ($conn->query($q) === TRUE) 
        {
            //Print success to the screen
            echo "Record updated successfully \n";
        } 
        else 
        {
            //query failed print the error and the username of the offending tuple
            echo "Error updating record: " . $conn->error;
            echo " \n The record that failed to upload properly is " . $User;  
        }
    }


}

/* Simple Function that is deisgned to check the status on a web page. if the web page is greater than a 200 (OK) then we want to return true other wise the request is good and we want
to return false. This function will be modified later on to account for all possible HTTP/HTTPS Response codes. */
function NetworkError(){
    $NetworkResponse = $http_response_code(); 
    if($NetworkResponse < 200){
        //We got a bad Network code, Redirect them to a 404 page
        return TRUE; 
    }
    //Response was a good one!
    return FALSE; 

}

/* Simple redirect program. If an error occured on the page or loading the page then we want to send a redirect to a known 404 web page to help manage error handling and stop showing when 
programs are erroring out*/
function errorpagere($isError)
{
    //Take in a variable and see if the web page has an error
    if($isError === TRUE){
        //Redirect
        header("Location: 404NotFound.php");
    }
    //Leave the web page
    exit();
}

/******************************************************START LOG FILE***************************************************************** */
/*
Some form of Log in the dection of INjection Attacks!
*/
//Take in an IP address and append it to the Black List log 
function AddBlackList($IP)
{
    //Open the file and cast to a var
    $fp = fopen("Blacklist.txt", "a");
    //Write the IP and format the file  
    fwrite($fp, 'IP Address: ' . $IP);
    //Add an empty line for the next entry  
    fwrite($fp, '\n');  
    //Close the file 
    fclose($fp);  
}
//Take all of the IPs tracked in the log file and place into its own unique file for further automation 
function AddAllIps()
{
    //open the log file
    $fp = fopen("Log.txt", "r"); 
    //Keep going until the end of the file 
    while(eofgets($fp))
    {
        //Get the data
        $data = fgets(); 
        //Open the new file to print too 
        $fps = fopen("Ip.txt", "a");
        //Write the ip address to the file   
        fwrite($fps, 'IP Address: ' . substr($data,13,28));  
        //NEw line written to the file 
        fwrite($fps, '\n');  
        //Close the file 
        fclose($fps);  
    }
    fclose($fp); 
}
//Function takes in an IP then checks the ip against the list of black listed Ip addresses
function ScanBlackList($IP)
{
    //Set a flag to flase
    $counter = false; 
    //Open the black list file 
    $fp = fopen("Blacklist.txt", "r");
    //Keep going until the end of the file is found
    while(!eofgets($fp)){
        //Get a line of data 
        $Data = fgets($fp); 
        //SEt a flag to see if true or false 
        $counter = strpos($Data,$IP);
        //If true 
        if($counter === true){
            //Redirect to a dead page 
            header("Location: 404NotFound.php");
            //Exit
            exit(); 
        }
        //Go to the next one 
        continue; 
    }
    //Close the file 
    fclose($fp); 
}
//Detect the number of times a port was scanned other than 8080
function detectPortscanFile()
{
    //Start a counter var
    $Susp = 0; 
    //Open the log file 
    $fp = fopen("Log.txt", "r"); 
    //WHile not the end of the file 
    while(!eofgets($fp))
    {
        //Get the next line of data in the file 
        $data = fgets($fp); 
            //If the string is not in the line of data 
            if(!strpos($data,"Port Number: 8080"))
            {
                //Increment the counter we found a port other than 8080 
                $Susp++; 
            }
        //Go to the next one 
        continue; 
    }
    //Close the file 
    fclose($fp); 
    //If more than 10 suspicious activity scanning ports other than 8080 true
    if($Susp >= 10)
    {
        //Return true
        return true; 
    }
    //Return false 
    return false; 
}
function detectsqlfile()
{
    $Susp = 0; 

    $tags = array(); 
    array_push($tags,'select','union', 'where', 'or', 'and', 'group', 'schema', 'table', 'alter', 'as', 'avg','between',
    'case','count','create','delete','group','by', 'having','inner','join','outer','insert','null',
    'like','limit', 'distinct', 'update','with','from');
 
    //Open the log file 
    $fp = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt", "r");
    
    while(!eofgets($fp)){
        $data = fgets($fp);
            //Loop through each word in the array 
        foreach($tags as $Tag_parse)
        {
            //echo $String_To_Parse; 
            $Holdup = array(); 
            $Holdup = permutations($Tag_parse); 
            //Loop through each of the words that have been generated in the permutations
            foreach($Holdup as $Newpermut)
            {
                $flag = false; 
                $flag = strpos($Data,$Newpermut); 
                if($flag === true)
                {
                    $Susp++; 
                } 
            }
        }
        //Continue to the next one 
        continue; 
    }
    fclose($fp); 
    if($Susp >= 15){
        return true; 
    }
    return false; 

}
function detectjsfile()
{
    //Set an array with all of the tags that we are parsing for 
    $tags = array(); 
    array_push($tags, 'html', 'head', 'body', 'frameset', 'script', 'noscript', 'style', 'meta', 'link', 'title', 'frame',
    'noframes', 'section', 'nav', 'aside', 'hgroup', 'header', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
     'pre', 'div', 'blockquote', 'hr', 'address', 'figure', 'figcaption', 'form', 'fieldset', 
    'del', 'dl', 'dt', 'dd', 'table', 'caption', 'thead', 'tfoot', 'tbody', 'colgroup', 'col',
    'td', 'video', 'audio', 'canvas', 'details',  'plaintext', 'template', 'article', 
    'svg', 'object', 'base', 'font', 'tt', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd',
    'var', 'cite', 'abbr', 'time', 'acronym', 'mark', 'ruby', 'rt', 'rp',  'img',  'wbr', 'map',
    'sub', 'sup', 'bdo', 'iframe', 'embed', 'span', 'input', 'select', 'textarea', 'label', 'button', 'optgroup',
    'option', 'legend', 'datalist', 'keygen', 'output', 'progress', 'meter', 'area', 'param', 'source', 'track',
    'summary', 'command', 'device', 'area', 'basefont', 'bgsound', 'menuitem', 'param', 'source', 'track',
    'data', 'bdi','meta', 'link', 'base', 'frame', 'img', 'wbr', 'embed', 'hr', 'input', 'keygen', 'command',
    'device', 'area', 'basefont', 'bgsound', 'menuitem', 'param', 'source', 'track', 'input', 'keygen', 'object', 'select', 'textarea');
    $Suspicions = 0; 
    $counter = false; 
    $fp = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt", "r");
    while(!eofgets($fp)){
        //Cast the data from a line of the file into a variable
        $Data = fgets($fp); 
    
            //Now we check for JS injection 
            //Run the permutations 
            foreach($tags as $Tag_parse){

                //echo $String_To_Parse; 
                $Holdup = array(); 
                $Holdup = permutations($Tag_parse); 
                //Loop through each of the words that have been generated in the permutations
                foreach($Holdup as $Newpermut)
                {
                    $flag = false; 
                    $flag = strpos($Data,$Newpermut); 
                    if($flag === true)
                    {
                        $Suspicions++; 
                    } 
                }
        }
        //Go to the next one
        continue; 
    }
    fclose($fp); 
    if($Suspicions >= 20)
    {
        return true; 

    }
    return false; 
}
function DetectPortScanip($IP)
{
    $Susp = 0; 
    $isflag = false; 
    $fp = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt", "r");
    while(!eofgets($fp))
    {
        $data = fgets($fp); 
        $isflag = strpos($data,$IP); 
        if($isflag === true){
            if(!strpos($data,"Port Number: 8080"))
            {
                $Susp++; 
            }
        }

        continue; 

    }
    fclose($fp); 
    return $Susp; 


}
function DetectSQLip($IP)
{
    $Susp = 0; 

    $tags = array(); 
    array_push($tags,'select','union', 'where', 'or', 'and', 'group', 'schema', 'table', 'alter', 'as', 'avg','between',
    'case','count','create','delete','group','by', 'having','inner','join','outer','insert','null',
    'like','limit', 'distinct', 'update','with','from');
    $ipflag = false; 

    //Open the log file 
    $fp = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt", "r");
    
    while(!eofgets($fp)){
        $data = fgets($fp);
        $ipflag = strpos($data,$IP);             
        if($ipflag === true)
        {
            //Now we need to check to see if the Data in the log is injected

            
            //Loop through each word in the array 
            foreach($tags as $Tag_parse)
            {
                //echo $String_To_Parse; 
                $Holdup = array(); 
                $Holdup = permutations($Tag_parse); 
                //Loop through each of the words that have been generated in the permutations
                foreach($Holdup as $Newpermut)
                {
                    $flag = false; 
                    $flag = strpos($Data,$Newpermut); 
                    if($flag === true)
                    {
                        $Susp++; 
                    } 
                }
            }
        }
        //Continue to the next one 
        continue; 
    }
    fclose($fp); 
    return $Susp; 
}
function DetectJSip($IP)
{
    //Set an array with all of the tags that we are parsing for 
    $tags = array(); 
    array_push($tags, 'html', 'head', 'body', 'frameset', 'script', 'noscript', 'style', 'meta', 'link', 'title', 'frame',
    'noframes', 'section', 'nav', 'aside', 'hgroup', 'header', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
     'pre', 'div', 'blockquote', 'hr', 'address', 'figure', 'figcaption', 'form', 'fieldset', 
    'del', 'dl', 'dt', 'dd', 'table', 'caption', 'thead', 'tfoot', 'tbody', 'colgroup', 'col',
    'td', 'video', 'audio', 'canvas', 'details',  'plaintext', 'template', 'article', 
    'svg', 'object', 'base', 'font', 'tt', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd',
    'var', 'cite', 'abbr', 'time', 'acronym', 'mark', 'ruby', 'rt', 'rp',  'img',  'wbr', 'map',
    'sub', 'sup', 'bdo', 'iframe', 'embed', 'span', 'input', 'select', 'textarea', 'label', 'button', 'optgroup',
    'option', 'legend', 'datalist', 'keygen', 'output', 'progress', 'meter', 'area', 'param', 'source', 'track',
    'summary', 'command', 'device', 'area', 'basefont', 'bgsound', 'menuitem', 'param', 'source', 'track',
    'data', 'bdi','meta', 'link', 'base', 'frame', 'img', 'wbr', 'embed', 'hr', 'input', 'keygen', 'command',
    'device', 'area', 'basefont', 'bgsound', 'menuitem', 'param', 'source', 'track', 'input', 'keygen', 'object', 'select', 'textarea');
    $Suspicions = 0; 
    $counter = false; 
    $fp = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt", "r");
    while(!eofgets($fp)){
        //Cast the data from a line of the file into a variable
        $Data = fgets($fp); 
    
        $counter = strpos($Data,$IP);
        //Is the IP apart of the line listed in the log file
        if($counter === true)
        {
            //Now we check for JS injection 
            //Run the permutations 
            foreach($tags as $Tag_parse){

                //echo $String_To_Parse; 
                $Holdup = array(); 
                $Holdup = permutations($Tag_parse); 
                //Loop through each of the words that have been generated in the permutations
                foreach($Holdup as $Newpermut)
                {
                    $flag = false; 
                    $flag = strpos($Data,$Newpermut); 
                    if($flag === true)
                    {
                        $Suspicions++; 
                    }
                
                }
                // echo 'This is a test of a function call'; 
            
            }
        }
        //Go to the next one
        continue; 
    }
    fclose($fp); 
    return $Suspicions

}
function logentry($ip, $port,$Pagename, $data)
{
    //Open the file 
    $fp = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt", "a");//opens file in append mode  
    fwrite($fp,"IP Address: " . $ip); 
    fwrite($fp,"     "  . "Port Number: " . $port ); 
    fwrite($fp,"     "  . "Web Page: " . $Pagename); 
    fwrite($fp,"     " . "Data : "); 
    foreach($data as $datas){
        fwrite($fp,$datas);
        fwrite($fp,"     ");  
    }    
    fwrite($fp, '\n');  
    fclose($fp); 
}
//Take in an error and report the error in the Log 
function ErrorLogEntry($Error)
{
    //Calculate the time of error occuring
    $ErrorDate = date("Y-m-d"); 
    $fp = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\ErrorLog.txt", "a");//opens file in append mode  
    fwrite($fp, "Encountered Error: " . $Error);  
    fwrite($fp, "       "); 
    fwrite($fp,"Time the Error Occurred: " . $ErrorDate); 
    fwrite($fp, '\n');  
    fclose($fp);  
     
}
function PrintLastTenErrors()
{
    $myfile = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\ErrorLog.txt", "r") or die("Unable to open file!"); 
    for($i = 0; $i < 10; $i++)
    {
        if(!eofgets($myfile)){
            echo fgets($myfile);
        }
        continue; 
        
    }
    fclose($myfile);
}
function PrintlastHundrendErrors()
{
    $myfile = fopen("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\ErrorLog.txt", "r") or die("Unable to open file!"); 
    for($i = 0; $i < 100; $i++)
    {
        if(!eofgets($myfile)){
            echo fgets($myfile);
        }
        continue; 
    }
    fclose($myfile);
}

/*************************************************END LOG FILE **************************************************************************** */

//Method to move all of the Personal Information into a new table as well as encryption method for viewing the data
	/*
	 * 
	 * Function assumes the use of a Senntinel Schema 
	 *
DROP TABLE Personalinfo IF exists;
CREATE TABLE Personalinfo(
    personID INTEGER NOT NULL AUTO_INCREMENT,
    pUserID INTEGER NOT NULL, 
    Fname VARCHAR(255) NOT NULL, 
    lname varchar(255) NOT NULL, 
    StreetAddress VARCHAR(255) NOT NULL,
    States VARCHAR(255) NOT NULL, 
    zip INTEGER, 
    phonenumber varchar(255) NOT NULL, 
    email varchar(255) NOT NULL,  
    PRIMARY KEY(personID), 
    FOREIGN KEY(pUserID) REFERENCES USER(ID)
);
	 * 
	 * 
	 * */
	
function SecuringData()
{
        //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
        $servername = "localhost";
        $username = "*****";
        $password = "******";
        $dbname = "******";
        //Start a connection with the database
        $conn = new mysqli($servername, $username, $password, $dbname);
        //Mock Query needed to grab all PI based on your DB layout
        $q = ""; 
        $results = $conn -> query($q); 
        //Grab all of the results 
        $nums = $results -> fetch_row(); 
        for($i = 0; $i < $nums; $i++){
            //Insert into the new tables 
            $qu = "INSERT INTO Personalinfo VALUES()"; 
            $resulting = $conn ->query($qu); 
            //Offset the variables 
            //Get the next batch of data to update
        }
}
	//Accessing the Perosnal information that we created in the DB
function AccessingPI($Username)
{
        $data = array(); 
        //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
        $servername = "localhost";
        $username = "*****";
        $password = "******";
        $dbname = "******";
        //Start a connection with the database
        $conn = new mysqli($servername, $username, $password, $dbname);
        //Write a query to access all of the data in the PI
        $q = "SELECT * From Personalinfo where username ='$Username'"; 
        $results = $conn -> query($q); 
        $r = $results[0]; 
        $r1 = $results[1]; 
        $r2 = $results[2]; 
        $r3 = $results[3]; 
        $r4 = $results[4]; 
        $r5 = $results[5]; 
        $r6 = $results[6]; 
        $r7 = $results[7]; 
        $r8 = $results[8];
        $r9 = $results[9];  
        //Encrypt here
        array_push($data,$r);
        array_push($data,$r1);
        array_push($data,$r2);
        array_push($data,$r3);
        array_push($data,$r4);
        array_push($data,$r5);
        array_push($data,$r6);
        array_push($data,$r7);
        array_push($data,$r8);
        array_push($data,$r9);
        return $data; 
}

/*24 hour rotating Cipher */
function TodaysCipher(){ return "AES-128-CTR"}
/*24 hour rotating key */
function TodaysKey(){return "Qurant1n3";}
/*24 hour rotating Vec */
function TodaysVec(){ return "1234567891065430";}
/*24 hour rotating options*/
function TodaysOptions(){return 0;}
/*Function that is designed to encrypt data being passed between systems */
function Encrypt($String_To_ENcrypt)
{
    //Get Todays Key
    $key = TodaysKey(); 
    //Get Todays Cipher
    $cipher = TodaysCipher();
    $vector = TodaysVec();  
    // Use OpenSSl Encryption method 
    openssl_cipher_iv_length($cipher); 
    //Set Field to be 0 
    $options = TodaysOptions(); 
    //Encrypt the string with todays cipher and key
    $Encrypted_String = openssl_encrypt($String_To_ENcrypt, $cipher,$key, $options, $vector); 
    //Return the Encrypted String
    return $Encrypter_String; 
}
/* Function designed to decrypt data */
function Decrpyt($String_To_Decrypt){
    //Get Todays Key 
    $key = TodaysKey(); 
    //Get Todays Cioher
    $cipher = TodaysCipher(); 
    $vector = TodaysVec(); 
    $options = TodaysOptions(); 
    $decryption=openssl_decrypt ($String_To_Decrypt, $cipher,$key, $options, $vector); 
    return $decryption; 
}


/*The purpose of this function is to serve as an authentication piece assuming that all passwords are only encrypted with SHA 256. This is to be done by taking the stored hash value
and then comparing that value to the hashed value of the password generated. If the hashs are equal then we return true and if not we return false. Every line has been commented so
that it is easy to manipulate this API and add salt to hashes*/
function newAuthSha256($StringToAuth,$user){
  //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
  $servername = "localhost";
  $username = "*****";
  $password = "******";
  $dbname = "******";

  //Start a connection with the database
  $conn = new mysqli($servername, $username, $password, $dbname);
  //Write a query that is designed to get the hash value of a usernames password
  $q = "SELECT pass from users where username = '$user'"; 
  //Get the results from the query 
  $results = $conn -> query($q); 
  //Store the password hash that is in the database
  $passhash = $results[0]; 
  //Rehash on our new updated hash IE sha 256 
  $hashpass = hash('sha256',$StringToAuth); 
  //If the new generated hash is equal to the stored DB hash then we authenticate
  if($hashpass === $passhash){
      return TRUE; 
  }
  //Else we return false
  return FALSE; 

}




?>