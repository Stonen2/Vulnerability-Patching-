<?php
//Created by Nick Stone 
//Secure progamming to parse user input to detect and defend SQL injection XSS and JS injection


//echo 'Hello World'; 
//For now we are just going to print the string to the page to get used to php
/*The function is desigened to take in a string that is going to be parsed as a means to mitigate and stop Cross Site scripting as well as javascript injection This is done by first
Looping through a given string and parsing out with regular expression a series of known special characters. Once this is done an array is populated with known HTML and Javascript
Commands that are then run through a permutation function which returns all of the possible permutations of a given String. From this these are then padded with / in order to run 
Regular expressions against in PHP and then parsed against the input string Replacing all commands that would be invoked by HTML or JS with ""
*/
function javascriptparse($String_To_Parse){
    //Parse some evil stuff right off the bat 
    //$String_To_Parse = preg_replace('/@///%/^/&/*/</>//:/;/]', '',$String_To_Parse); 
    //[@,#,$,%,^,&,*,<,>,/,',:,;']
    //$String_To_Parse = preg_replace('///', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/@/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/#/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/$/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/%/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/^/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/&/', '',$String_To_Parse); 
   // $String_To_Parse = preg_replace('/*/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/</', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/>/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace("/'/", '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/:/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/;/','',$String_To_Parse); 
    //$String_To_Parse = preg_replace('///','',$String_To_Parse); 
    //Make and populate an array with every possible Tag that could be used to hurt us'
    $tags = array(); 
    array_push($tags, 'html', 'head', 'body', 'frameset', 'script', 'noscript', 'style', 'meta', 'link', 'title', 'frame',
    'noframes', 'section', 'nav', 'aside', 'hgroup', 'header', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
     'pre', 'div', 'blockquote', 'hr', 'address', 'figure', 'figcaption', 'form', 'fieldset', 
    'del', 'dl', 'dt', 'dd', 'table', 'caption', 'thead', 'tfoot', 'tbody', 'colgroup', 'col',
    'td', 'video', 'audio', 'canvas', 'details',  'plaintext', 'template', 'article', 
    'svg', 'object', 'base', 'font', 'tt', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd',
    'var', 'cite', 'abbr', 'time', 'acronym', 'mark', 'ruby', 'rt', 'rp',  'img',  'wbr', 'map',
    'sub', 'sup', 'bdo', 'iframe', 'embed', 'span', 'input', 'select', 'textarea', 'label', 'button', 'optgroup',
    'option', 'legend', 'datalist', 'keygen', 'output', 'progress', 'meter', 'area', 'param', 'source', 'track',
    'summary', 'command', 'device', 'area', 'basefont', 'bgsound', 'menuitem', 'param', 'source', 'track',
    'data', 'bdi','meta', 'link', 'base', 'frame', 'img', 'wbr', 'embed', 'hr', 'input', 'keygen', 'command',
    'device', 'area', 'basefont', 'bgsound', 'menuitem', 'param', 'source', 'track', 'input', 'keygen', 'object', 'select', 'textarea');

//Lets set up the parsing now 

foreach($tags as $Tag_parse){

    //echo $String_To_Parse; 
    $Holdup = array(); 
    $Holdup = permutations($Tag_parse); 
    //Loop through each of the words that have been generated in the permutations
    foreach($Holdup as $Newpermut)
    {
        //Need to pad with the / characters for php to run the regular expression against
        $tos = '/'; 
        $tos .= $Newpermut; 
        $tos .= '/'; 
    
    //echo $Newpermut; 
    //Regular expression to remove the generated chatacters if in the string
    $String_To_Parse = preg_replace($tos, '',$String_To_Parse); 
    
    }
    // echo 'This is a test of a function call'; 

    }



    // echo $Holdup[1]; 
    /*
    Following code is example code for PHP regular expression find and replace!
$string = 'The quick brown fox jumps over the lazy dog.';
$patterns = array();
$patterns[0] = '/quick/';
$patterns[1] = '/brown/';
$patterns[2] = '/fox/';
$replacements = array();
$replacements[2] = 'bear';
$replacements[1] = 'black';
$replacements[0] = 'slow';
echo preg_replace($patterns, $replacements, $string);   


preg_replace(RegularExpression, Replacement Text, String to parse)
    */

    //Return the given String
    return $String_To_Parse; 

}
/*The purpose of this function is to take in a given String and return all possible permutations of how the word could be entered in an array. For example suppose the String abc.Some
Web servers will execute all JS SQL Inject commands even if weird or abnormal capitilization is placed on a given String. So given the example abc the following Strings would be put
into an array and would be returned to the calling function. 
abc,Abc,aBc,abC,ABc,AbC,aBC,ABC.
*/
function permutations($input) 
{ 
     //We need to cast the string to be lowercase This is our base case
    $input = strtolower($input);  
    //Create a new array to hold all of the values
    $permutation_Array = array();   
    //Need to loop through so we need to gather the number of characters in the string
    $length = strlen($input);  
    //We know Length^2 number of permutations
    $max = pow(2,$length); 
    //Set a counter to loop with 
    $i = 0; 
    //Set a loop to loop through all of the possible combinations
    while($i < $max){
        //Combination is equal to the lowercase value of the input 
        $combination = $input; 
        //Set a j counter
        $j = 0; 
        //Loop through to find each of the permuations of this string
        while ($j < $length){
            //Bit Shift with a bitwise AND operation to determine which characters will be uppercase
            if((($i >> $j) & 1) == 1){
              //Change the character to be upper case
              $combination[$j] = chr(ord($combination[$j]) - 32); 
            }  
            $j++; 
        } 
        //push the new word with the upper case values onto the array and do it again
        array_push($permutation_Array,$combination); 
        //Increment I
        $i++; 
        //Jump back up to the loop and do it again 
        continue; 
    } 
    //Return the array that contains all of the possible permutations
    return $permutation_Array; 

} 



/*The purpose of this function is to take in a string that will be enetered into some form of query. the purpose of this is to sanitize the input as to mitigate and stop SQL injection
attacks by going through a string and first parsing out a series of unwanted characters... These being special characters. Then the program will loop through a pre-generated array of 
known sql commands and will run through each permutation of the word before generating a regular expression to parse out each of the permutated words that have been generated. */ 
function SqlInjectionParse($String_To_Parse){


    //Create an array and push all of the SQL short codes into the array 
    $tags = array();
    //The following lines of code parse out unwanted and particularly special characters that should not be included in most user Strings
    $String_To_Parse = preg_replace('/@/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/#/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/$/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/%/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/^/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/&/', '',$String_To_Parse); 
   // $String_To_Parse = preg_replace('/*/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/</', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/>/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace("/'/", '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/:/', '',$String_To_Parse); 
    $String_To_Parse = preg_replace('/;/','',$String_To_Parse); 
    //Push some known sql commands onto the array for us to permutate and then use to remove these words from the string
    array_push($tags,'select','union', 'where', 'or', 'and', 'group', 'schema', 'table', 'alter', 'as', 'avg','between',
    'case','count','create','delete','group','by', 'having','inner','join','outer','insert','null',
    'like','limit', 'distinct', 'update','with','from');


    //Loop through each word in the array 
    foreach($tags as $Tag_parse){


        //echo $String_To_Parse; 
        //Create a new array
        $Holdup = array(); 
        //Cast the new array to hold all of the possible permutations of the word in question
        $Holdup = permutations($Tag_parse); 
        //Loop Through each of the permutations
        foreach($Holdup as $Newpermut)
        {
            //Pad the word with / in order to run regular expressions against
            $tos = '/'; 
            $tos .= $Newpermut; 
            $tos .= '/'; 
        
        //echo $Newpermut; 
        //Replace each of the found permutations with "" 
        $String_To_Parse = preg_replace($tos, '',$String_To_Parse); 
      //  echo $String_To_Parse; 
        }
        // echo 'This is a test of a function call'; 
    
    }
    //Return the sanitized input
    return $String_To_Parse; 


}


/*

Some form of Log in the dection of INjection Attacks!

*/


function logentry()
{


}

/*This function is designed to update every users password hash in the users databse in a given web database. This is done by first establishing a connection to the database
Then the program gets the total number of users in the database to then create a loop to go through each user, track its username assuming username is the primary key as well 
as update the password by sending the password through a SHA 256. This could lead to a double hash however this is not a problem. This then inserts the new password back into 
the database on a given primary key assuming username is the primary key. The program has error handling to tell the program if a record failed or was successfully updated. 
The error handling does inform the user which user failed to be updated. 
*/
function hashupdate(){
    //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
    $servername = "localhost";
    $username = "*****";
    $password = "******";
    $dbname = "******";

    //Start a connection with the database
    $conn = new mysqli($servername, $username, $password, $dbname);
    //Write a Query to gather all users from the database including passwords
    $query  = "SELECT username, passwd FROM users";
    //Execute the query
    $results = $conn -> query($query);
    //Get the total number of results in the query (Num users) 
    $numusers = $results -> fetch_row(); 
//Create a loop to update every user in the database
    for($i = 0; $i < $numusers; $i++){
        //Username is stored at position 0
        $username = $results[0]; 
        //PAssword given at position 1
        $pass = $results[1];
        //Update the hash on the password
        $pass = hash('sha256', $pass);
        //Now update the given record with the new SHA 256 pass Assumes Username is primary key 
        $q = "UPDATE users
            SET passwd = '$pass'
            WHERE username = '$username'
            ";
        //If the query was succesful
        if ($conn->query($q) === TRUE) 
        {
            //Print success to the screen
            echo "Record updated successfully \n";
        } 
        else 
        {
            //query failed print the error and the username of the offending tuple
            echo "Error updating record: " . $conn->error;
            echo " \n The record that failed to upload properly is " . $username;  
        }
    }


}
/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (MD5) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
function newauthMD5($String_To_Auth,$User){
    //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
    $servername = "localhost";
    $username = "*****";
    $password = "******";
    $dbname = "******";

    //Start a connection with the database
    $conn = new mysqli($servername, $username, $password, $dbname);
    //Write a query that is designed to get the hash value of a usernames password
    $q = "SELECT pass from users where username = '$user'"; 
    //Execute the query
    $results = $conn -> query($q); 
    //Get the results from thr query
    $passhash = $results[0]; 
    //Hash the first time in the original hash assuming md5
    $hashpass = hash('md5',$String_To_Auth); 
    //Hash on the new hash that we gave, IE sha 256
    $hashpass = hash('sha256',$hashpass); 

    //If they are equal its the same pass
    if($hashpass === $passhash){
        return TRUE; 
    }
    //Else it is not
    return FALSE; 

}
/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (SHA 1) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
function newauthSHA1($String_To_Auth,$user){
  //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
  $servername = "localhost";
  $username = "*****";
  $password = "******";
  $dbname = "******";

  //Start a connection with the database
  $conn = new mysqli($servername, $username, $password, $dbname);
  //Write a query that is designed to get the hash value of a usernames password
  $q = "SELECT pass from users where username = '$user'"; 
  //Get the results from the query 
  $results = $conn -> query($q); 
  //Store the password hash that is in the database
  $passhash = $results[0]; 
  
  //First hash on sha1 (legacy)
  $hashpass = hash('sha1',$String_To_Auth); 
  //Rehash on our new updated hash IE sha 256 
  $hashpass = hash('sha256',$hashpass); 
  //If the new generated hash is equal to the stored DB hash then we authenticate
  if($hashpass === $passhash){
      return TRUE; 
  }
  //Else we return false
  return FALSE; 



}


//this function is to be used if an individual email is sent out for users to create a new password for authentication purposes
/*This function is designed to update every users password hash in the users databse in a given web database. This is done by first establishing a connection to the database
Then the program gets the total number of users in the database to then create a loop to go through each user, track its username assuming username is the primary key as well 
as update the password by sending the password through a SHA 256. This could lead to a double hash however this is not a problem. This then inserts the new password back into 
the database on a given primary key assuming username is the primary key. The program has error handling to tell the program if a record failed or was successfully updated. 
The error handling does inform the user which user failed to be updated. 
*/
function hashupdateemail($PassToStore,$User){
    //Set your database information in the fields given. These can be moved to a constants file which may be added later on 
    $servername = "localhost";
    $username = "*****";
    $password = "******";
    $dbname = "******";
    //Start a connection with the database
    $conn = new mysqli($servername, $username, $password, $dbname);
        //Update the hash on the password
        $PassToStore= hash('sha256', $PassToStore);
        //Now update the given record with the new SHA 256 pass Assumes Username is primary key 
        $q = "UPDATE users
            SET passwd = '$PassToStore'
            WHERE username = '$User'
            ";
        //If the query was succesful
        if ($conn->query($q) === TRUE) 
        {
            //Print success to the screen
            echo "Record updated successfully \n";
        } 
        else 
        {
            //query failed print the error and the username of the offending tuple
            echo "Error updating record: " . $conn->error;
            echo " \n The record that failed to upload properly is " . $User;  
        }
    }


}


?>
