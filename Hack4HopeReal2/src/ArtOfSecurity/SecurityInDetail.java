package ArtOfSecurity;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Scanner;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.mysql.jdbc.Statement;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;


/* Created By Nick Stone on 2/2/2020
 * 
 * MODULE COMMENTS: 
 * This module is designed to be implemented by pre-existing Legacy web applications that run on JSP or other older Java Web Frameworks
 * This Package aims to resolve and defend against several security vulnerabilities and exploit attacks. 
 * 
 * We currently defend against: 
 * JS Injection 
 * SQL injection 
 * WEak hashing 
 * Basic Encryption 
 * Personal Information Housing 
 * Log File Writing 
 * Port Scan Detection 
 * Error Log File
 * Detecting JS injection 
 * Detecting SQL injection 
 * New AUthentication 
 * New Password Hashing 
 *
 *
 *
 * Contact Nick Stone to work on this open source project
 * */



public class SecurityInDetail 
{

/*--------------------------------------------------------------CONSTANT VARIABLES----------------------------------------------------------------- */
	//CONST variables for cleaner code
	public static final int ZERO = 0; 
	public static final int HUNDRED = 100; 
	public static final int BITSHIFT = 1; 
	public static final int OFFSET = 32; 
	public static final int TWO = 2; 
	public static final int TWOHUNDRED = 200; 
	public static final int TEN = 10; 


/*--------------------------------------------------------------CONSTANT VARIABLES----------------------------------------------------------------- */



	//List of Key words that are used in Java scriot injection attacks
    private static final String[] JSTags = {
            "html", "head", "body", "frameset", "script", "noscript", "style", "meta", "link", "title", "frame",
            "noframes", "section", "nav", "aside", "hgroup", "header", "footer", "h1", "h2", "h3", "h4", "h5", "h6",
             "pre", "div", "blockquote", "hr", "address", "figure", "figcaption", "form", "fieldset", 
            "del", "dl", "dt", "dd", "table", "caption", "thead", "tfoot", "tbody", "colgroup", "col",
            "td", "video", "audio", "canvas", "details",  "plaintext", "template", "article", 
            "svg","object", "base", "font", "tt", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd",
            "var", "cite", "abbr", "time", "acronym", "mark", "ruby", "rt", "rp",  "img",  "wbr", "map",
            "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "button", "optgroup",
            "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track",
            "summary", "command", "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track",
            "data", "bdi","meta", "link", "base", "frame", "img", "wbr", "embed", "hr", "input", "keygen", "command",
            "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track","input", "keygen", "object", "select", "textarea"
    };
	//List of Key words that are used in SQL injection attacks, is also good to stop SQL commands inserted in queries
	private static final String[] sqlinje = {
		"select","union", "where", "or", "and", "group", "schema", "table", "alter", "as", "avg","between",
		"case","count","create","delete","group","by", "having","inner","join","outer","insert","null",
		"like","limit", "distinct", "update","with","from"
	}; 
	//This is a SQL Injection Prevention Method
	//Need to Document and Revisit to Refactor:
	/*This function is the sql injection prevention. This is done by taking in a String and then parsing out a series of known bad characters as well as parsing out known SQL commands */
	public static String parses(String sql) {
		//Set a string equal to the String we are sanitizing
		String Newstr = sql; 
		//String stringtoparse = ""; 
		//Parse out known special characters
		Newstr = Newstr.replaceAll("[@,#,$,%,^,&,*,<,>,/,',:,;',=,+,-]", "");
		//SEt the String to be all lower case
		Newstr.toLowerCase();
		//Parse the commands to 
		ArrayList<String> perm = new ArrayList();
		for(int i = 0; i < sqlinje.length; i++) {
				//Get all of the permutations of a given word
				perm = permutations(sqlinje[i]); 
				for(int j = 0; j < perm.size(); j++) {
					//get the word we are parsing
					String stp = perm.get(j); 
					//System.out.println(s);
					//Regular expression to get rid of all of these words
					newStr = newStr.replaceAll(stp,""); 
				}
			}	
		//Return the sanitized String
		return newStr; 
	}
	
	
	//JavaScript Injection
	/*This function is the Java script and XSS prevention script. This is done by taking in a String and then parsing out known special characters. After this the program loops through
	3 arrays that hold unique HTML and JS commands. Each command will be sent to have permutations made of each of the words and then regular expressions look for those words and replace them
	these are usually as javascript injection attacks */
	public static String parsejavascript(String sanitize) {
		//Write a Regular Expression to parse out all <Script> Tags!
		//Set a string to the string that is to be sanitized
		String newStr = sanitize; 
		//Set an array 
		ArrayList<String> gs = new ArrayList<String>(); 
		//Parse all the java script tags
		for(int i = 0; i < JSTags.length; i++) {
			//Permute each of the words in the block tags array
			gs = permutations(JSTags[i]); 
			for(int j = 0; j < gs.size(); j++) {
				//Set a string to one of the permuted words
				String stp = gs.get(j); 
				//System.out.println(s);
				//Remove this permutation from the string if found
				newStr = newStr.replaceAll(stp,""); 
			}
		}
		//Replace all special characters with a regular expression
		newStr = newStr.replaceAll("[@,#,$,%,^,&,*,<,>,/,',:,;']", "");	
		//Return the sanitized String
		return newStr; 
	}
	

	/*The purpose of this function is to take in a given String and return all possible permutations of how the word could be entered in an array. For example suppose the String abc.Some
	Web servers will execute all JS SQL Inject commands even if weird or abnormal capitilization is placed on a given String. So given the example abc the following Strings would be put
	into an array and would be returned to the calling function. 
	abc,Abc,aBc,abC,ABc,AbC,aBC,ABC.
	Base code written by Mike Spear refactored by Nick Stone
	*/
	 static ArrayList<String> permutations(String attack) 
	    { 
			//Set this to be all lowercase
			attack = attack.toLowerCase();  
			// Set a new array 
		 	ArrayList<String> tts = new ArrayList(); 
	        //Get the length of the string
			int lengthstring = attack.length();
	        //2 ^n possible combinations
			double max = Math.pow(TWO, lengthstring); 
			//SEt a counter to be 0 
	        int i = ZERO; 
			//While i is less than the total number of combinations
	        while(i < max){
				//Set a character array to the string in questions
	            char stri[] = attack.toCharArray(); 
				//Set a counter for j 
	            int j = 0; 
				//Start another loop for the length of the word
	            while(j < lengthstring){
					//If the i bit shift right J times with a bitwise & is 1 then 
	                if(((i >> j) &  BITSHIFT) == BITSHIFT) 
	                {
						//Set the Character to be upper case
	                    stri[j] = (char) (stri[j]-OFFSET); 
	                }
					//Increment j
	                j++; 
	            }  
	            //System.out.println(stri); 
				//Get the value of the string into a new string
	            String fsd = String.valueOf(stri); 
	            //Add the new string to the array
				tts.add(fsd);   
				//Increment I 
	            i++;
				//Continue
	            continue; 
	        } 
			//Return the array with all of the words in it
	        return tts; 
	    } 
	
	
	//Function is designed to test the HTTP response CODE and then redirect the user if anything other than a 200 is founds
	public static void NetworkError(HttpServletResponse response) throws IOException {
		try {
			//Get the response code
			int s = response.getStatus();
			//Greater than 200 send it to a redirect 
			if(s > TWOHUNDRED) {
				//Not ok
				response.sendRedirect("FileNotFound.jsp"); 
			}
		}
		catch(Exception e){
			//Log the error
			LogError(e); 
			//send the response
			response.sendRedirect("FileNotFound.jsp");
		}
	}
	
	/*-------------------------------------------------Log File--------------------------------------------*/
	//Create an Error Log: Take in an exception that will be thrown in a try catch and then place this error in the log file for further analysis
	public static void LogError(Exception error){
		try
		{
	    //We want the date of the Error
		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd");
		LocalDateTime now = LocalDateTime.now();
		//Open the file and set to true so we can append the file
		FileWriter Writer = new FileWriter("ErrorLog.txt", true); 
		 //Write a series of formatted data to the file 
		 Writer.append("Encountered Error: " + error);
		 Writer.append("       "); 
		 Writer.append("Time the Error Occurred: " + dtf.format(now));
		 Writer.append("\n"); 
		 //Close the file
		 Writer.close(); 
		}
		catch(Exception e){
			//Print the error to the screen since we cannot print the error to the log 
			System.out.println("ERROR: " + e); 
			System.out.println("UNABLE TO PRINT AN ERROR TO THE LOG FILE"); 
		}
	}
	//The purpose of this function is to loop through the log file and print the first 10 entries that the log file experienced
	public static void last10errors(){
		try{
			//Set a counter variable
			int counter = ZERO; 
			//Open the file no need to write we are just reading
			File file = new File("ErrorLog.txt");
			//Create a Scanner object for the file
			Scanner input = new Scanner(file);
			//Loop through the file
			while(input.hasNextLine()) 
			{
				//Only want 10 entries
				if(counter >= TEN){
					//Break the loop 
					break; 
				}
				//Set the string to the be the next line of input in the file 
				String nextToken = input.nextLine();
				//Print the file to the screen 
				System.out.println(nextToken); 
				//Increment counter and do it again 
				counter++; 
			}
		}
		catch(Exception e){
			//Experienced an error report the error to the log file 
			LogError(e); 
			System.out.println("Error: " + e); 
		}
	}
	
	//The purpose of this function is to print the last 100 errors in the log file to the screen 
	public static void last100Errors(){
		try{
			//Set a counter variable that we will loop through the file 
			int counter = ZERO; 
			// Just reading the file no need to write
			File file = new File("ErrorLog.txt");
			//Scanner object to read the input 
			Scanner input = new Scanner(file);
			//Loop through the file 
			while(input.hasNextLine()) 
			{
				//If the counter is greater than 100 we are done
			    if(counter >= HUNDRED){
					//Break out of the loop 
			    	break; 
			    }
				//Take the next input and cast to a string
				String nextToken = input.nextLine();
				//Print the string to the screen 
				System.out.println(nextToken); 
				//Increment Counter
				counter++; 
			}
		}
		catch(Exception e){
			//Log the error
			LogError(e); 
			//Print the error to the screen 
			System.out.println("Error: " + e); 
		}
	}
	//The purpose of this function is to print all of the IP addresses that are listed in the IP file
	public static void printaddresses(){

		try{
			//Set a counter
			int counter = 0;
			//Open the file  
			File file = new File("Ip.txt");
			//Set a scanner to read the file 
			Scanner input = new Scanner(file);
			//As long as there is anotehr line in the file keep looping 
			while(input.hasNextLine()) 
			{
				//Cast the next line to be a string
				String nextToken = input.nextLine();
				//Print the string to the screen 
				System.out.println(nextToken);  
			}
		}
		catch(Exception e){
			//Log the error 
			LogError(e); 
			//Print what happened to the screen 
			System.out.println("Error: " + e); 
		}
				
	}
	
	//The purpose of this function is to loop through the log file and get all of the IP addresses and move them to the IP.txt for further analysis and continued automation 
	public static void getalladdresses(){
		try{
		//Open the file we only need to read
		File file = new File("Log.txt");
		//Build a scanner to read in the file 
		Scanner input = new Scanner(file);
		//Loop through the file for each line in the file 
		while(input.hasNextLine()) {
		    //Cast a string to the next line in the file
			String nextToken = input.nextLine();
			//Get the IP address from the substring 
			String ip = nextToken.substring(13,28); 
			//Write this ip to the file
			FileWriter Writer = new FileWriter("Ip.txt", true); 
			//Ip write
			Writer.append(ip); 
			//File Formatting 
			Writer.append("\n"); 
			//Close the file 
			Writer.close(); 
			//Go to the next one 
			continue; 		
		}
		}
		catch(Exception e){
			//Log the error 
			LogError(e); 
			//Print the error to the screen 
			System.out.println("Error: " + e); 
		}
	}
	//The purpose of this function is to check each line in the log file to see if people were trying to access ports other than 8080
	private static boolean AllFilePortScan() 
	{
		//Set a flag
		boolean flag = false; 
		try{
		//Reading a port scan
		int Susp = 0; 
		//Read the file 
		File file = new File("Log.txt");
		//Create a scanner to read the file 
		Scanner input = new Scanner(file);
		//Loop through each line in the file 		
		while(input.hasNextLine()) {
			//Cast String to the next line 
		    String nextToken = input.nextLine();
		    	//Now we need to check if the line has the "Port Address: 8080"
		    	if(nextToken.contains("Port Number: 8080") == false){
		    		Susp++; 
		    	}
		    //Go to the next line 
		    continue; 
		}
		//Close the file 
		input.close();
		//if more than 3 none 8080 Probably a port scan 
		if(Susp > 3){
			//True
			flag = true;
		}
		}
		catch(Exception e){
			//Log the error 
			LogError(e); 
		}

		//Return the findings
		return flag; 
	}
	//The purpose of this function is to loop through the entire log file and identify if there is possibly been a user trying to perform a SQL injection 
	public static boolean AllfileSQL(){
		try{
		//Reading a port scan
		
		int offenses = 0; 
		int Susp = 0; 
	 	File file = new File("Log.txt");
		Scanner input = new Scanner(file);
		//We want to write a regular expression to find the IP in a given Line need it to be true else go next line
		while(input.hasNext()) {
		    String nextToken = input.nextLine();
		    //System.out.println(nextToken); 
		    //Run a regular exrepssion
		    	//Now we are going to loop through and find the SQL injection prevention techniques and increment the number
		    	ArrayList<String> perm = new ArrayList();
				for(int ii = 0; ii < sqlinje.length; ii++) {
						//Get all of the permutations of a given word
						perm = permutations(sqlinje[ii]); 
						for(int jj = 0; jj < perm.size(); jj++) {
							//get the word we are parsing
							String s = perm.get(jj); 
							//System.out.println(s);
							//Regular expression to get rid of all of these words
							//System.out.println(s); 
							if(nextToken.contains(s) == true) {
								Susp++; 
							
							}
					}
		    }
		    //Loop to the next one
		    continue; 
		    //or to process line by line
		    //String nextLine = input.nextLine();
		}
		//Return the number of suspicious activity 
		if(Susp >= 30){
			//Return true an attack happened
			return true;
		}
		//No Attack 
		return false; 
		}
		catch(Exception e){
			//Print the error Log the error just return false 
			System.out.println("ERROR: " + e); 
			LogError(e); 
			return false; 
		}
		
		}
	//The purpose of this function is to loop through the entire log file and determine whether or not someone performed a JS injection 
	public static boolean AllfileJS(){
		try{
		//Set a var to 0 
		int Susp = ZERO;
		//Open the Log File path  
		File file = new File("Log.txt");
		//Create a scanner object to read the file 
		Scanner input = new Scanner(file);
		//Loop through the entire file 
		while(input.hasNextLine()) {
			//Cast the variable to a string 
		    String nextToken = input.nextLine();
			//Create an array list 
			ArrayList<String> gs = new ArrayList<String>(); 
				//Block Tags Permutated
				for(int ii = 0; ii < JSTags.length; ii++) {
					//Permute each of the words in the block tags array
					gs = permutations(JSTags[ii]); 
					for(int jj = 0; jj < gs.size(); jj++) {
						//Set a string to one of the permuted words
						String s = gs.get(jj); 
						if(nextToken.contains(s)){
							Susp++; 
							//System.out.println(s); 
						}
					 
					}
				}
		}
		
		if(Susp > 30){
			//Return true probably an attack somewhere
			return true; 
		}
		//Return False probably not an attack 
		return false; 
		}
		catch(Exception e){
			//Log the error and return false 
			LogError(e); 
			return false; 
		}
	}
	
	
	//This function will take in an Ip address and then list the IP address on the Black list log file 
	public static boolean blackList(String IP){
		//Write a bad IP to a file 
		try{ 
		 FileWriter Writer = new FileWriter("Log.txt", true); 
		 Writer.append("IP Address: " + IP);
		 Writer.append("\n"); 
		 Writer.close(); 
		}
		catch(Exception e){	
			System.out.println("Error: " + e); 
			LogError(e); 
			//Failed
			return false; 
		}
		//Success!
		return true; 
	}
	
	/*The purpose of this function is to log a series of events that a user interacts with when using the website. To do this we have the web page track some data for us
	 *like the IP Address of the user, the port number, the data that they are entering before we parse, and the name of the page that they are on We simply log all of this 
	 *into a text file */
	public static void initilizeLog(String Ip, String po, String pname, ArrayList<String>Data) {
	try {
		//Open a file and true so we can append to the file  
		  FileWriter Writer = new FileWriter("Log.txt", true); 
		  //Add a bunch of data and format the data in the file 
		  Writer.append("IP Address: " + Ip);
		  Writer.append("     "  + "Port Number: " + po );
		  Writer.append("     "  + "Web Page: " + pname);
		  Writer.append("     " + "Data : "); 
		  //Loop through the data array and print to the file 
		  for(int i = 0; i < Data.size(); i++){
			  Writer.append(Data.get(i));
			  Writer.append("     ");
			  
		  }
		  //Format the file
		  Writer.append("\n");
		  //Close the file  
	      Writer.close();
	      //System.out.println("Success"); 
	}
	catch(Exception e) {
		//Print the error to the screen and log the error 
		System.out.println("Error: " + e); 
		LogError(e); 
	}
		
	}
	
	//We give the program an IP then we search the log file for the IP and identify if the port number is anything other than 8080 
	private static int Detectportscan(String IP){
	//Reading a port scan
		int Susp = 0; 
		try{
		File file = new File("Log.txt");
		Scanner input = new Scanner(file);
		while(input.hasNext()) {
		    String nextToken = input.nextLine();
		    boolean flag = false; 
		    flag = nextToken.contains(IP); 
		    if(flag == true)
		    {	
		    	//Now we need to check if the line has the "Port Address: 8080"
		    	if(nextToken.contains("Port Number: 8080") == false){
		    		Susp++; 
		    	}
		    }
		    //Go to the next line 
		    continue; 
		}
		//Close the file 
		input.close();
		}
		catch(Exception e){
			//Log the error
			LogError(e); 
		}
		//Return the suspicious number 
		return Susp; 
	}
	/*Take in a given IP address and see if the ip address is on the black list, if the ip address is on the block list send them to a bad page*/
	private static void Blacklist(String IP, HttpServletResponse r){
		try{
		//Reading a port scan
		File file = new File("Blacklist.txt");
		//Create a scanner object to read the file 
		Scanner input = new Scanner(file);
		//Keep looping through the file 
		while(input.hasNext()) {
			//Cast the String to the next line in the file 
		    String nextToken = input.nextLine();
		    if(nextToken.contains(IP)){
		    	try 
				{
					//Send the redirect and do not let them view the web page
					r.sendRedirect("FileNotFound.jsp");
				} 
				catch (IOException e) {
					//Print the error to the screen 
					System.out.println("Error: " + e); 
					//Log the error 
					LogError(e); 

				}
		    }
			//Continue 
		    continue; 
		}
		}
		catch(Exception e){
			//Log the error 
			LogError(e); 
		}
	}
	//The purpose of this function is to take in an IP and then search the log file everywhere the IP has been tracked and then identify if the IP has tried to use JS injection
	private static int detectJS(String IP) {
		//Reading a port scan
		int Susp = 0; 
		try{
		//Create a file that is to read in the log file 
		File file = new File("Log.txt");
		//Create a Scanner object to read in a file 
		Scanner input = new Scanner(file);
		//Continue to loop through the entire file 
		while(input.hasNextLine()) {
			//Cast the next line in the file as a String
		    String nextToken = input.nextLine();
			//Create a flag 
		    boolean flag = false;
			//If the IP is in the given line  
		    flag = nextToken.contains(IP);
		    if(flag == true) {
				String a = "@"; 
			    String b = "#";
			    String c = "$"; 
			    String d = "%";
			    String e = "^"; 
			    String f = "&"; 
			    String g = "*"; 
			    String h = "<"; 
			    String i = ">"; 
			    String j = "/"; 
			    String k = "'";
			    String l = ":";  
			    String n = "'"; 
			    String o = "="; 
			    String p = "+"; 
			    String q = "-";  
			    //If is has any special character give it a score of one it might be OK 
			    if(IP.contains(a)||IP.contains(b)|| IP.contains(c)|| IP.contains(d) || IP.contains(e) || IP.contains(f) || IP.contains(g) ||IP.contains(h)|| IP.contains(i) || IP.contains(j) || IP.contains(k)|| IP.contains(l) || IP.contains(n) || IP.contains(o) || IP.contains(p)|| IP.contains(q)) {
			    	Susp++; 
			    }
				//Create an array List for permutation s
				ArrayList<String> gs = new ArrayList<String>(); 
				//Parse all the java script tags
				//Block Tags Permutated
				for(int ii = 0; ii < JSTags.length; ii++) {
					//Permute each of the words in the block tags array
					gs = permutations(JSTags[ii]); 
					for(int jj = 0; jj < gs.size(); jj++) {
						//Set a string to one of the permuted words
						String s = gs.get(jj); 
						if(nextToken.contains(s)){
							Susp++; 
							//System.out.println(s); 
						}
					 
					}
				}
		}
		}
		}
		catch(Exception e){
			//Log the error 
			LogError(e); 
		}
		//Return the suspicious amount 
		return Susp; 
	}
	//Purpose of the function is to find every line the IP given has been logged and see if they have performed a SQL injection 
	private static int detectsql(String IP) {
		//Reading a port scan
		int offenses = 0; 
		int Susp = 0; 
		try{
	 	File file = new File("Log.txt");
		Scanner input = new Scanner(file);
		//We want to write a regular expression to find the IP in a given Line need it to be true else go next line
		while(input.hasNext()) {
		    String nextToken = input.nextLine();
		    //System.out.println(nextToken); 
		    //Run a regular exrepssion
		    boolean flag = false; 
		    flag = nextToken.contains(IP);
		    if(flag == true) {
		    	//Now we know that this IP has been logged, lets check for SQL in the data
		    	//Check for some evil characters
		    	//String aa = "[@,#,$,%,^,&,*,<,>,/,',:,;',=,+,-", "");
		    	String a = "@"; 
		    	String b = "#";
		    	String c = "$"; 
		    	String d = "%";
		    	String e = "^"; 
		    	String f = "&"; 
		    	String g = "*"; 
		    	String h = "<"; 
		    	String i = ">"; 
		    	String j = "/"; 
		    	String k = "'";
		    	String l = ":";  
		    	String n = "'"; 
		    	String o = "="; 
		    	String p = "+"; 
		    	String q = "-";  
		    	
		    	if(IP.contains(a)||IP.contains(b)|| IP.contains(c)|| IP.contains(d) || IP.contains(e) || IP.contains(f) || IP.contains(g) ||IP.contains(h)|| IP.contains(i) || IP.contains(j) || IP.contains(k)|| IP.contains(l) || IP.contains(n) || IP.contains(o) || IP.contains(p)|| IP.contains(q)) {
		    		Susp++; 
		    	}
		    	//Now we are going to loop through and find the SQL injection prevention techniques and increment the number
		    	ArrayList<String> perm = new ArrayList();
				for(int ii = 0; ii < sqlinje.length; ii++) {
						//Get all of the permutations of a given word
						perm = permutations(sqlinje[ii]); 
						for(int jj = 0; jj < perm.size(); jj++) {
							//get the word we are parsing
							String s = perm.get(jj); 
							if(nextToken.contains(s) == true) {
								//Suspicious String Found 
								Susp++; 
							}
						}
					}
		    	//Lets Permutate through the S
		    }
		    //Loop to the next one
		    continue; 
		    //or to process line by line
		    //String nextLine = input.nextLine();
		}
		}
		catch(Exception e){
			//Log the error 
			LogError(e); 
		}
		
		//Return the number of suspicious activity 
		return Susp; 
	}
 
	
/*-------------------------------------------End Log File-----------------------------------------*/
	
/*-------------------------------------------------------------Begin Password Hashes----------------------------------------------------------- */

	/*This function is designed to update every users password hash in the users databse in a given web database. This is done by first establishing a connection to the database
Then the program gets the total number of users in the database to then create a loop to go through each user, track its username assuming username is the primary key as well 
as update the password by sending the password through a SHA 256. This could lead to a double hash however this is not a problem. This then inserts the new password back into 
the database on a given primary key assuming username is the primary key. The program has error handling to tell the program if a record failed or was successfully updated. 
The error handling does inform the user which user failed to be updated. 
*/
	public static void UpdateHashAll(){
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "****";
		String password  = "*********";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		//Create the SQL statement 	
		java.sql.Statement stmt = conn.createStatement();
		//Execute the query 
		ResultSet rs = stmt.executeQuery("SELECT username, password from user"); 
		//Keep going through result set
		while(rs.next())
		{
			//Gather some data from the origianl query 
			String Username = rs.getString("username"); 	 
			String unhashpassword = rs.getString("password"); 
			unhashpassword = encryptSHA256(unhashpassword); 
			//Rehash password
			//Insert back into users
			//Query to update the Query
			String sql = "UPDATE user SET password = '"+unhashpassword+"' where username = '"+Username+"'";
			//Create the query 
			PreparedStatement preparedInsert = conn.prepareStatement(sql);
			//Execute the query 
			preparedInsert.execute(sql);

		}	    
		}
		catch(Exception e){
			//Print the error to the screen and log the error  
			System.out.println("An Error has occurerd"); 
			System.out.println(e); 
			LogError(e); 
			
		}
	}
	/*The purpose of this function is to serve as an authentication piece assuming that all passwords are only encrypted with SHA 256. This is to be done by taking the stored hash value
and then comparing that value to the hashed value of the password generated. If the hashs are equal then we return true and if not we return false. Every line has been commented so
that it is easy to manipulate this API and add salt to hashes*/
	private static boolean NewAuthenitcation256(String username, String pass)
	{
	//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "****";
		String password  = "*********";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			//authentication success!
			return true; 

		}
		//Failed to authenticate 
		return false; 
		}
		catch(Exception e){
			//Print and log the error 
			System.out.println("THe error that was thrown is " + e); 
			LogError(e); 
		}
		//Failed to tauthentcate
		return false; 
	}
	/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (SHA 1) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
	private static boolean NewAuthenticationsha1(String username, String pass)
	{
		//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "****";
		String password  = "*********";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to MD5
		pass = encryptSHA1(pass); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			//Authentication success!
			return true; 

		}
		//Did not authenticate
		return false; 

		}
		catch(Exception e){
			//Print and log the error 
			System.out.println("THe error that was thrown is " + e); 
			LogError(e); 
		}



		//Did not authenticate
		return false; 
	}
/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (MD5) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
	private static boolean NewAuthenticationmd5(String username,String pass)
	{
		//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "****";
		String password  = "*********";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to MD5
		pass = encryptMD5(pass); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			//Return true
			return true; 

		}
		//Return false
		return false; 

		}
		catch(Exception e){
			//Print and log error
			System.out.println("THe error that was thrown is " + e); 
			LogError(e); 
		}
		//Return false 
		return false; 

	
	}
/*-------------------------------------------------------------End Password Hashes----------------------------------------------------------- */

	//Method to move all of the Personal Information into a new table as well as encryption method for viewing the data
	/*
	 * 
	 * Function assumes the use of a Senntinel Schema 
	 *
DROP TABLE Personalinfo IF exists;
CREATE TABLE Personalinfo(
    personID INTEGER NOT NULL AUTO_INCREMENT,
    pUserID INTEGER NOT NULL, 
    Fname VARCHAR(255) NOT NULL, 
    lname varchar(255) NOT NULL, 
    StreetAddress VARCHAR(255) NOT NULL,
    States VARCHAR(255) NOT NULL, 
    zip INTEGER, 
    phonenumber varchar(255) NOT NULL, 
    email varchar(255) NOT NULL,  
    PRIMARY KEY(personID), 
    FOREIGN KEY(pUserID) REFERENCES USER(ID)
);
	 * 
	 * 
	 * */
		//Purpose of this function is to gather all personal information from a user from all of the tables and place them in one table in the database for easy encryption 
	private static void PersonalInformationDB(String username)
	{	
		//Connnect to the database 
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "****";
		String password  = "********";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
	    
	    //Write a query to gather all of the old PI needs to be changed to fit the datbase
	    java.sql.Statement stmt = conn.createStatement();
	    //Insert Query Results into the new table
	    
	    //Query to get some data just a mock query
	    ResultSet rs = stmt.executeQuery("SELECT fName,email from users where username = " + username); 
	    //Get the data from the query 
	    String first = rs.getString("fName");
	    String email = rs.getString("email");
	    String sql = "INSERT INTO  `eogotwa_h4hProject`.`Personalinfo` (`Username`, `fName`, "
	    				+ "`email`)" + " VALUES ('"+username+"', '"+first+"'," + "'"+email+"'+);";
	    PreparedStatement preparedInsert = conn.prepareStatement(sql);
	    
	    preparedInsert.execute(sql);
		//Insert the data into a secure table so we can encrypt and decrypt
		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
			LogError(e); 
		}		
	}
	//purpose of this function is to gather all of the PI that a given user has and prepare the data and then encrypt the data 
	private static ArrayList<String> AccessingPI(String username)
	{
		
		//Connnect to the database 
		ArrayList<String> data = new ArrayList<String>(); 
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "****";
		String password  = "*********";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
	    
	    //Write a query to gather all of the old PI needs to be changed to fit the datbase
	    java.sql.Statement stmt = conn.createStatement();
	    //Insert Query Results into the new table
	    
	    //Query to get some data just a mock query
	    ResultSet rs = stmt.executeQuery("SELECT fName,email from Personalinfo where username = " + username); 
	    //Get the data from the query 
	    String email = rs.getString("email"); 
	    String first = rs.getString("fName"); 
	    //Add the data into the array list 
	    data.add(email); 
	    data.add(first); 
	    
		//Insert the data into a secure table so we can encrypt and decrypt
		}
		catch(Exception e){
			//Print the error to the screen and log the error 
			System.out.println("THe error that was thrown is " + e); 
			LogError(e); 
		}
		//Return the array list 
		return data;		
	}
	
	/*-----------------------------------------Encryption-----------------------------------------*/
	//The purpose of this function is to take in a string and then encrypt the string such that it has some encryption 
	private static byte[] encrypt(String data){
		//Turn the String into a byte array 
		byte enc[] = data.getBytes(); 
		//make a new byte array
		byte[] newen = new byte[enc.length];
		//Looop through array 
		for(int i = 0; i < enc.length; i++){
			//If even 
			if(i %2 == 0)
			{
				//Add one to the value
				newen[i] = (byte) (enc[i] + 1); 
			}
			//If odd
			else
			{
				//Subtract 1
				newen[i] =  (byte) (enc[i] - 1); 
			}
		}
		//Return the newly encrypted byte array 
		return newen; 
	}
	
	//The purpose of this function is to take in a byte array and then decrypt the byte array the inverse of the encryption method
	private static byte[] decrypt(byte [] encrypted){
		//Make a new byte array
		byte[] newen = new byte[encrypted.length];
		//Iterate through the byte array 
		for(int i = ZERO; i < encrypted.length; i++){
			//If Even
			if(i % TWO == ZERO){
				//Subtract
				newen[i] = (byte) (encrypted[i] - ONE); 
			}
			//If Odd
			else{
				//Add one 
				newen[i] =  (byte) (encrypted[i] + ONE); 
				
			}
		}
		//Return Byte arrary of decrypted data
		return newen; 
	}
	
	
	/*-------------------------------------END ENCRYPTION-----------------------------------------------*/
	//Purpose of this function is to take in a username and a new password to replace the old password in the database 
	private static void updatehashreplace(String passTo, String username)
	{
		//Create a connection 
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "****";
		String password  = "*********";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		//Encrypt the password
		passTo = encryptSHA256(passTo); 
		//Creat the sql query to update the user 
		String sql = "UPDATE users SET password = '"+passTo+"' where username = '"+username+"'";
		//Create a SQL query 
		PreparedStatement preparedInsert = conn.prepareStatement(sql);
		//Execute the statement
		preparedInsert.execute(sql);
		}
		catch(Exception e){
			//Print and log the error 
			System.out.println("THe error that was thrown is " + e); 
			LogError(e); 
		}
	}
	
	//The purpose of this function is to take in a string and encrypt the string with sha 256
	public static String encryptSHA256(String needencrypt)
	{
		//Create a new string 
		String NewHashed = ""; 
		try{
		//Set the hash value to be sha256
		 MessageDigest digest = MessageDigest.getInstance("SHA-256");
         //Cast the sha256 to a byte array 
		 byte[] bytarr = digest.digest(needencrypt.getBytes());
         //Create a String builder 
		 StringBuilder newstr = new StringBuilder();
         for(int i=0; i< bytarr.length ;i++)
         {
            newstr.append(Integer.toString((bytarr[i] & 0xff) + 0x100, 16).substring(1));
         }
		 //Cast the hash to the string 
        NewHashed = newstr.toString();
		}
		catch(Exception e){
			//Log the error 
			LogError(e); 
		}
		//Return the new string
		return NewHashed; 
	}
	/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (SHA 1) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
	public static String encryptSHA1(String needencrypt){
		//Create a new string 
		 String NewHashed = ""; 
		 try{
		//Encrypt the message with SHA 1
		 MessageDigest digest = MessageDigest.getInstance("SHA-1");
         //Cast to a byte array 
		 byte[] bytarr = digest.digest(needencrypt.getBytes());
         //Build the string 
		 StringBuilder newstr = new StringBuilder();
         for(int i=0; i< bytarr.length ;i++)
         {
			 //Building a string 
            newstr.append(Integer.toString((bytarr[i] & 0xff) + 0x100, 16).substring(1));
         }
		 //Cast the new string 
        NewHashed = newstr.toString();
		 }
		 catch(Exception e){
			 //Log Error 
			 	LogError(e); 
		 }
		//Return the new hashed 
		return NewHashed; 
	}
	//purpose of this function is to take in a string and then encrypt the string with MD5 then encrypt the string with SHA 256
	public static String encryptMD5(String needencrypt){
		//Create a new string 
		String NewHashed = ""; 
		try{
		//Set the authentication to be md5
		 MessageDigest digest = MessageDigest.getInstance("MD5");
         //Cast the authentication MD5 to a byte array 
		 byte[] bytarr = digest.digest(needencrypt.getBytes());
         //Create a String builder
		 StringBuilder newstr = new StringBuilder();
         for(int i=0; i< bytarr.length ;i++)
         {
			 //String builder to rebuild the string form the byte array 
            newstr.append(Integer.toString((bytarr[i] & 0xff) + 0x100, 16).substring(1));
         }
		 //Cast the hash to the new string 
        NewHashed = newstr.toString();
        //System.out.println(NewHashed); 
		}
		catch(Exception e){
			//Log the error 
			LogError(e); 
		}
		//Return the new hash
		return NewHashed; 		
	}


	
	
	
	

	
}