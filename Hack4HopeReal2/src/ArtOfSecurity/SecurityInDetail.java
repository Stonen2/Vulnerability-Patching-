package ArtOfSecurity;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Scanner;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.mysql.jdbc.Statement;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;


/* Created By Nick Stone on 2/2/2020
 * 
 * MODULE COMMENTS: 
 * This module is designed to be implemented by pre-existing Legacy web applications that run on JSP or other older Java Web Frameworks
 * This Package aims to resolve and defend against several security vulnerabilities and exploit attacks. 
 * 
 * We currently defend against: 
 * Contact Nick Stone to work on this open source project
 * */



public class SecurityInDetail 
{

	//List of Key words that are used in Java scriot injection attacks
    private static final String[] blockTags = {
            "html", "head", "body", "frameset", "script", "noscript", "style", "meta", "link", "title", "frame",
            "noframes", "section", "nav", "aside", "hgroup", "header", "footer", "h1", "h2", "h3", "h4", "h5", "h6",
             "pre", "div", "blockquote", "hr", "address", "figure", "figcaption", "form", "fieldset", 
            "del", "dl", "dt", "dd", "table", "caption", "thead", "tfoot", "tbody", "colgroup", "col",
            "td", "video", "audio", "canvas", "details",  "plaintext", "template", "article", 
            "svg"
    };
	//List of Key words that are used in JavaScript injection attacks
    private static final String[] inlineTags = {
            "object", "base", "font", "tt", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd",
            "var", "cite", "abbr", "time", "acronym", "mark", "ruby", "rt", "rp",  "img",  "wbr", "map",
            "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "button", "optgroup",
            "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track",
            "summary", "command", "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track",
            "data", "bdi"
    };
	//List of Key words that are used in javaScript injection attacks  
    private static final String[] emptyTags = {
            "meta", "link", "base", "frame", "img", "wbr", "embed", "hr", "input", "keygen", "command",
            "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track"
    };
  
  
    private static final String[] formSubmitTags = {
            "input", "keygen", "object", "select", "textarea"
    };
	//List of Key words that are used in SQL injection attacks, is also good to stop SQL commands inserted in queries
	private static final String[] sqlinje = {
		"select","union", "where", "or", "and", "group", "schema", "table", "alter", "as", "avg","between",
		"case","count","create","delete","group","by", "having","inner","join","outer","insert","null",
		"like","limit", "distinct", "update","with","from"
	}; 
	
	
	

	//This is a SQL Injection Prevention Method
	//Need to Document and Revisit to Refactor:
	/*This function is the sql injection prevention. This is done by taking in a String and then parsing out a series of known bad characters as well as parsing out known SQL commands */
	public static String parses(String sql) {
		//Set a string equal to the String we are sanitizing
		String aa = sql; 
		//String stringtoparse = ""; 
		//Parse out known special characters
		aa = aa.replaceAll("[@,#,$,%,^,&,*,<,>,/,',:,;',=,+,-]", "");
		//SEt the String to be all lower case
		aa.toLowerCase();
		//Parse the commands to 
		ArrayList<String> perm = new ArrayList();
		for(int i = 0; i < sqlinje.length; i++) {
				//Get all of the permutations of a given word
				perm = permutations(sqlinje[i]); 
				for(int j = 0; j < perm.size(); j++) {
					//get the word we are parsing
					String s = perm.get(j); 
					//System.out.println(s);
					//Regular expression to get rid of all of these words
					aa = aa.replaceAll(s,""); 
				}
			}
		
		
		//Parse all of the SQL commands out of the String.
		
		
		
		//Then Implement a Secure injection
		
		//System.out.println(aa); 
		//Return the sanitized String
		return aa; 
	}
	
	
	//JavaScript Injection
	/*This function is the Java script and XSS prevention script. This is done by taking in a String and then parsing out known special characters. After this the program loops through
	3 arrays that hold unique HTML and JS commands. Each command will be sent to have permutations made of each of the words and then regular expressions look for those words and replace them
	these are usually as javascript injection attacks */
	public static String parsejavascript(String sanitize) {
		//Write a Regular Expression to parse out all <Script> Tags!
		//Set a string to the string that is to be sanitized
		String bb = sanitize; 
		//Set an array 
		ArrayList<String> gs = new ArrayList<String>(); 
		//Parse all the java script tags
		//TODO Turn this into a regular expression
		
		//Block Tags Permutated
		for(int i = 0; i < blockTags.length; i++) {
			//Permute each of the words in the block tags array
			gs = permutations(blockTags[i]); 
			for(int j = 0; j < gs.size(); j++) {
				//Set a string to one of the permuted words
				String s = gs.get(j); 
				//System.out.println(s);
				//Remove this permutation from the string if found
				bb = bb.replaceAll(s,""); 
			}
		}
		//Just to make sure that <script> has  been removed
		gs = permutations("<script>"); 
		for(int j = 0; j < gs.size(); j++) {
			//String is set to a permutation of the <script> 
			String s = gs.get(j); 
			//System.out.println(s);
			//Replace all of these permutations with the regular expression
			bb = bb.replaceAll(s,""); 
		}
		//Take the permuation of the </script> 
		gs = permutations("</script>"); 
		for(int j = 0; j < gs.size(); j++) {
			//Get one of the permuated words
			String s = gs.get(j); 
			//System.out.println(s);
			//Regular expression parse out all of these from the string
			bb = bb.replaceAll(s,""); 
			
		}
		//Loop through all of the in line tags array words
		for(int i = 0; i < inlineTags.length; i++) {
			//Have the array hold the permutation of a given word
			gs = permutations(inlineTags[i]); 
			for(int j = 0; j < gs.size(); j++) {
				//Set a string to one of the words
				String s = gs.get(j); 
				//System.out.println(s);
				//Replace all of the words
				bb = bb.replaceAll(s,""); 
				
			}
		}
		//Loop through all of the empty tags array words
		for(int i = 0; i < emptyTags.length; i++) {
			//SEt an array to the permutations of one of the words
			gs = permutations(emptyTags[i]); 
			for(int j = 0; j < gs.size(); j++) {
				//Set a string to one of the words 
				String s = gs.get(j); 
				//System.out.println(s);
				//Replace all of these words from the String
				bb = bb.replaceAll(s,""); 
				
			}
		}
	//Loop through all of the form submitted tags 
	for(int i = 0; i < formSubmitTags.length; i++) {
		//Set an array to one of the permutations of the words
		gs = permutations(formSubmitTags[i]); 
		for(int j = 0; j < gs.size(); j++) {
			//String is set to one of the permuations 
			String s = gs.get(j); 
			//System.out.println(s);
			//Parse out all of the found strings
			bb = bb.replaceAll(s,""); 
			
		}
	}	
		/*
		bb = bb.replaceAll("<script>", "");
		bb = bb.replaceAll("</script>", "");
		bb = bb.replaceAll("<Script>", "");
		bb = bb.replaceAll("</Script>", "");
		*/
		//Replace all special characters with a regular expression
		bb = bb.replaceAll("[@,#,$,%,^,&,*,<,>,/,',:,;']", "");	
		//Return the sanitized String
		return bb; 
	}
	

	/*The purpose of this function is to take in a given String and return all possible permutations of how the word could be entered in an array. For example suppose the String abc.Some
	Web servers will execute all JS SQL Inject commands even if weird or abnormal capitilization is placed on a given String. So given the example abc the following Strings would be put
	into an array and would be returned to the calling function. 
	abc,Abc,aBc,abC,ABc,AbC,aBC,ABC.
	*/
	 static ArrayList<String> permutations(String attack) 
	    { 
			//Set this to be all lowercase
			attack = attack.toLowerCase();  
			// Set a new array 
		 	ArrayList<String> t = new ArrayList(); 
	        //Get the length of the string
			int lengthstring = attack.length();
	        //2 ^n possible combinations
			double max = Math.pow(2, lengthstring); 
			//SEt a counter to be 0 
	        int i = 0; 
			//While i is less than the total number of combinations
	        while(i < max){
				//Set a character array to the string in questions
	            char stri[] = attack.toCharArray(); 
				//Set a counter for j 
	            int j = 0; 
				//Start another loop for the length of the word
	            while(j < lengthstring){
					//If the i bit shift right J times with a bitwise & is 1 then 
	                if(((i >> j) &  1) == 1) 
	                {
						//Set the Character to be upper case
	                    stri[j] = (char) (stri[j]-32); 
	                }
					//Increment j
	                j++; 
	            }  
	            //System.out.println(stri); 
				//Get the value of the string into a new string
	            String fsd = String.valueOf(stri); 
	            //Add the new string to the array
				t.add(fsd);   
				//Increment I 
	            i++;
				//Continue
	            continue; 
	        } 
			//Return the array with all of the words in it
	        return t; 
	    } 
	
	
		//Testing
	public static void NetworkError(HttpServletResponse response) throws IOException {
		try {
			int s = response.getStatus(); 
			if(s > 200) {
				//Not ok
				response.sendRedirect("FileNotFound.jsp");
				//return false; 
			}
		
		}
		catch(Exception e){
			response.sendRedirect("FileNotFound.jsp");
		}
		//Ok
		//return true; 
		
		
	}
	
	/*-------------------------------------------------Log File--------------------------------------------*/
	//Create an Error Log
	public static void LogError(Exception e){
		t	ry
		{
			
			
			
		}
		catch(Exception e){
			System.out.println("ERROR: " + e); 
			System.out.println("UNABLE TO PRINT AN ERROR TO THE LOG FILE"); 
		}
		
		
	}
	public static void last10errors(){
		
	}
	
	public static void last100Errors(){
		
		
	}
	
	//Doable Maybe get a list of all IP addresses 
	public static void getalladdresses(){
		try{
		File file = new File("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt");
		Scanner input = new Scanner(file);
		while(input.hasNext()) {
		    
			String nextToken = input.nextLine();
		    //Grab the substring that we care about 
			
			
		
		}
		}
		catch(Exception e){
			System.out.println("Error: " + e); 
		}
	}
	
	
	public static boolean AllfileSQL(){
		
		return false; 
	}
	public static boolean AllfileJS(){
		try{
		int Susp = 0; 
		File file = new File("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt");
		Scanner input = new Scanner(file);
		while(input.hasNext()) {
		    String nextToken = input.nextLine();
			ArrayList<String> gs = new ArrayList<String>(); 
				//Parse all the java script tags
				//TODO Turn this into a regular expression
				
				//Block Tags Permutated
				for(int ii = 0; ii < blockTags.length; ii++) {
					//Permute each of the words in the block tags array
					gs = permutations(blockTags[ii]); 
					for(int jj = 0; jj < gs.size(); jj++) {
						//Set a string to one of the permuted words
						String s = gs.get(jj); 
						if(nextToken.contains(s)){
							Susp++; 
							//System.out.println(s); 
						}
					 
					}
				}
				//Loop through all of the in line tags array words
				for(int ii = 0; ii < inlineTags.length; ii++) {
					//Have the array hold the permutation of a given word
					gs = permutations(inlineTags[ii]); 
					for(int jj = 0; jj < gs.size(); jj++) {
						//Set a string to one of the words
						String s = gs.get(jj); 
						//System.out.println(s);
						if(nextToken.contains(s)){
							Susp++; 
							//System.out.println(s); 
						}
					}
				}
				//Loop through all of the empty tags array words
				for(int ii = 0; ii < emptyTags.length; ii++) {
					//SEt an array to the permutations of one of the words
					gs = permutations(emptyTags[ii]); 
					for(int jj = 0; jj < gs.size(); jj++) {
						//Set a string to one of the words 
						String s = gs.get(jj); 
						//System.out.println(s);
						if(nextToken.contains(s)){
							Susp++; 
							//System.out.println(s); 
						}
						
					}
				}
			//Loop through all of the form submitted tags 
			for(int ii = 0; ii < formSubmitTags.length; ii++) {
				//Set an array to one of the permutations of the words
				gs = permutations(formSubmitTags[ii]); 
				for(int jj = 0; jj < gs.size(); jj++) {
					//String is set to one of the permuations 
					String s = gs.get(jj); 
					//System.out.println(s);
					//Parse out all of the found strings
					if(nextToken.contains(s)){
						Susp++; 
						//System.out.println(s); 
					}	
				}
			}
		}
	
		if(Susp > 30){
			return true; 
		}
		return false; 
		}
		catch(Exception e){
			
			return false; 
		}
	}
	
	
	//Black list an ip? 
	public static boolean blackList(int IP){
		//Write a bad IP to a file 
		try{ 
		 FileWriter Writer = new FileWriter("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt", true); 
		 Writer.append("IP Addres: " + IP);
		 Writer.append("\n"); 
		 Writer.close(); 
		}
		catch(Exception e){	
			System.out.println("Error: " + e); 
			//Failed
			return false; 
		}
		//Success!
		return true; 
	}
	
	/*The purpose of this function is to log a series of events that a user interacts with when using the website. To do this we have the web page track some data for us
	 *like the IP Address of the user, the port number, the data that they are entering before we parse, and the name of the page that they are on We simply log all of this 
	 *into a text file */
	public static void initilizeLog(String Ip, String po, String pname, ArrayList<String>Data) {
	try {
		//System.out.println("In Try"); 
		  FileWriter Writer = new FileWriter("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt", true); 
		  Writer.append("IP Address: " + Ip);
		  Writer.append("     "  + "Port Number: " + po );
		  Writer.append("     "  + "Web Page: " + pname);
		  Writer.append("     " + "Data : "); 
		  for(int i = 0; i < Data.size(); i++){
			  Writer.append(Data.get(i));
			  Writer.append("     ");
			  
		  }
		  Writer.append("\n"); 
	      Writer.close();
	      //System.out.println("Success"); 
	}
	catch(Exception e) {
		System.out.println("Error: " + e); 
	}
		
	}
	
	//We give the program an IP then we search the log file for the IP and identify if the port number is anything other than 8080 
	private static int Detectportscan(String IP) throws FileNotFoundException {
	//Reading a port scan
		int Susp = 0; 
		File file = new File("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt");
		Scanner input = new Scanner(file);
		while(input.hasNext()) {
		    String nextToken = input.nextLine();
		    boolean flag = false; 
		    flag = nextToken.contains(IP); 
		    if(flag == true)
		    {	
		    	//Now we need to check if the line has the "Port Address: 8080"
		    	if(nextToken.contains("Port Number: 8080") == false){
		    		Susp++; 
		    	}
		    }
		    //Go to the next line 
		    continue; 
		}
		input.close();
		return Susp; 
	}
	/*Take in a given IP address and see if the ip address is on the black list, if the ip address is on the block list send them to a bad page*/
	private static void Blacklist(String IP, HttpServletResponse r) throws FileNotFoundException{
		//Reading a port scan
		File file = new File("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Blacklist.txt");
		Scanner input = new Scanner(file);
		while(input.hasNext()) {
		    String nextToken = input.nextLine();
		    if(nextToken.contains(IP)){
		    	try {
					r.sendRedirect("FileNotFound.jsp");
				} catch (IOException e) {
					System.out.println("Error: " + e); 
				}
		    }
		    continue; 
		}
	}

	private static int detectJS(String IP) throws FileNotFoundException {
		//Reading a port scan
		int Susp = 0; 
		File file = new File("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt");
		Scanner input = new Scanner(file);
		while(input.hasNext()) {
		    String nextToken = input.nextLine();
		    boolean flag = false; 
		    flag = nextToken.contains(IP);
		    if(flag == true) {
				String a = "@"; 
			    String b = "#";
			    String c = "$"; 
			    String d = "%";
			    String e = "^"; 
			    String f = "&"; 
			    String g = "*"; 
			    String h = "<"; 
			    String i = ">"; 
			    String j = "/"; 
			    String k = "'";
			    String l = ":";  
			    String n = "'"; 
			    String o = "="; 
			    String p = "+"; 
			    String q = "-";  
			    	
			    if(IP.contains(a)||IP.contains(b)|| IP.contains(c)|| IP.contains(d) || IP.contains(e) || IP.contains(f) || IP.contains(g) ||IP.contains(h)|| IP.contains(i) || IP.contains(j) || IP.contains(k)|| IP.contains(l) || IP.contains(n) || IP.contains(o) || IP.contains(p)|| IP.contains(q)) {
			    	Susp++; 
			    }
				ArrayList<String> gs = new ArrayList<String>(); 
				//Parse all the java script tags
				//TODO Turn this into a regular expression
				
				//Block Tags Permutated
				for(int ii = 0; ii < blockTags.length; ii++) {
					//Permute each of the words in the block tags array
					gs = permutations(blockTags[ii]); 
					for(int jj = 0; jj < gs.size(); jj++) {
						//Set a string to one of the permuted words
						String s = gs.get(jj); 
						if(nextToken.contains(s)){
							Susp++; 
							//System.out.println(s); 
						}
					 
					}
				}
				//Loop through all of the in line tags array words
				for(int ii = 0; ii < inlineTags.length; ii++) {
					//Have the array hold the permutation of a given word
					gs = permutations(inlineTags[ii]); 
					for(int jj = 0; jj < gs.size(); jj++) {
						//Set a string to one of the words
						String s = gs.get(jj); 
						//System.out.println(s);
						if(nextToken.contains(s)){
							Susp++; 
							//System.out.println(s); 
						}
					}
				}
				//Loop through all of the empty tags array words
				for(int ii = 0; ii < emptyTags.length; ii++) {
					//SEt an array to the permutations of one of the words
					gs = permutations(emptyTags[ii]); 
					for(int jj = 0; jj < gs.size(); jj++) {
						//Set a string to one of the words 
						String s = gs.get(jj); 
						//System.out.println(s);
						if(nextToken.contains(s)){
							Susp++; 
							//System.out.println(s); 
						}
						
					}
				}
			//Loop through all of the form submitted tags 
			for(int ii = 0; ii < formSubmitTags.length; ii++) {
				//Set an array to one of the permutations of the words
				gs = permutations(formSubmitTags[ii]); 
				for(int jj = 0; jj < gs.size(); jj++) {
					//String is set to one of the permuations 
					String s = gs.get(jj); 
					//System.out.println(s);
					//Parse out all of the found strings
					if(nextToken.contains(s)){
						Susp++; 
						//System.out.println(s); 
					}	
				}
			}
		}
		}
		return Susp; 
	}
	
	private static int detectsql(String IP) throws FileNotFoundException {
		//Reading a port scan
		int offenses = 0; 
		int Susp = 0; 
	 	File file = new File("C:\\Users\\vstone\\Desktop\\Hack4HopeReal2\\src\\ArtOfSecurity\\Log.txt");
		Scanner input = new Scanner(file);
		//We want to write a regular expression to find the IP in a given Line need it to be true else go next line
		while(input.hasNext()) {
		    String nextToken = input.nextLine();
		    //System.out.println(nextToken); 
		    //Run a regular exrepssion
		    boolean flag = false; 
		    flag = nextToken.contains(IP);
		    if(flag == true) {
		    	//Now we know that this IP has been logged, lets check for SQL in the data
		    	//Check for some evil characters
		    	//String aa = "[@,#,$,%,^,&,*,<,>,/,',:,;',=,+,-", "");
		    	String a = "@"; 
		    	String b = "#";
		    	String c = "$"; 
		    	String d = "%";
		    	String e = "^"; 
		    	String f = "&"; 
		    	String g = "*"; 
		    	String h = "<"; 
		    	String i = ">"; 
		    	String j = "/"; 
		    	String k = "'";
		    	String l = ":";  
		    	String n = "'"; 
		    	String o = "="; 
		    	String p = "+"; 
		    	String q = "-";  
		    	
		    	if(IP.contains(a)||IP.contains(b)|| IP.contains(c)|| IP.contains(d) || IP.contains(e) || IP.contains(f) || IP.contains(g) ||IP.contains(h)|| IP.contains(i) || IP.contains(j) || IP.contains(k)|| IP.contains(l) || IP.contains(n) || IP.contains(o) || IP.contains(p)|| IP.contains(q)) {
		    		Susp++; 
		    	}
		    	//Now we are going to loop through and find the SQL injection prevention techniques and increment the number
		    	
		    	
		    	ArrayList<String> perm = new ArrayList();
				for(int ii = 0; ii < sqlinje.length; ii++) {
						//Get all of the permutations of a given word
						perm = permutations(sqlinje[ii]); 
						for(int jj = 0; jj < perm.size(); jj++) {
							//get the word we are parsing
							String s = perm.get(jj); 
							//System.out.println(s);
							//Regular expression to get rid of all of these words
							//System.out.println(s); 
							if(nextToken.contains(s) == true) {
								Susp++; 
							}
						}
					}
				
		    	//Lets Permutate through the 
		    	
		    	
		    }
		    //Loop to the next one
		    continue; 
		    //or to process line by line
		    //String nextLine = input.nextLine();
		}

		
		//Return the number of suspicious activity 
		return Susp; 
	}
 
	
/*-------------------------------------------End Log File-----------------------------------------*/
	
/*-------------------------------------------------------------Begin Password Hashes----------------------------------------------------------- */

	/*This function is designed to update every users password hash in the users databse in a given web database. This is done by first establishing a connection to the database
Then the program gets the total number of users in the database to then create a loop to go through each user, track its username assuming username is the primary key as well 
as update the password by sending the password through a SHA 256. This could lead to a double hash however this is not a problem. This then inserts the new password back into 
the database on a given primary key assuming username is the primary key. The program has error handling to tell the program if a record failed or was successfully updated. 
The error handling does inform the user which user failed to be updated. 
*/
	public static void UpdateHashAll(){
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT username, password from user"); 
		while(rs.next())
		{
			String Username = rs.getString("username"); 	 
			String unhashpassword = rs.getString("password"); 
			unhashpassword = encryptSHA256(unhashpassword); 
			//Rehash password
			//Insert back into users
			//Query to update the Query
			String sql = "UPDATE user SET password = '"+unhashpassword+"' where username = '"+Username+"'";
			PreparedStatement preparedInsert = conn.prepareStatement(sql);
			preparedInsert.execute(sql);

		}	    
		}
		catch(Exception e){
			System.out.println("An Error has occurerd"); 
			System.out.println(e); 
			
		}
	}
	/*The purpose of this function is to serve as an authentication piece assuming that all passwords are only encrypted with SHA 256. This is to be done by taking the stored hash value
and then comparing that value to the hashed value of the password generated. If the hashs are equal then we return true and if not we return false. Every line has been commented so
that it is easy to manipulate this API and add salt to hashes*/
	private static boolean NewAuthenitcation256(String username, String pass)
	{
	//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			return true; 

		}
		return false; 
		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}
		return false; 
	}
	/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (SHA 1) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
	private static boolean NewAuthenticationsha1(String username, String pass)
	{
		//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to MD5
		pass = encryptSHA1(pass); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			return true; 

		}
		return false; 

		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}




		return false; 
	}
/*The purpose of thie function is to serve as a built in authentication piece that is supposed to be used after running the new password hashing algorithm written in the API. the purpose of this
Is to take an old widely used hash algorithm (MD5) and then first take a given username and password from a authentication site. Then we retrieve the stored hash of the password
From a given user that is entered into the authentication piece. Then we take the new password entered and regenerate the hash first running the SHA 1 hash then the SHA 256 hash. 
We then compare the hashes and if the newly generated hash matches the hash stored in the database then we authenticate. Else we return false as in no authentication */
	private static boolean NewAuthenticationmd5(String username,String pass)
	{
		//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to MD5
		pass = encryptMD5(pass); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			return true; 

		}
		return false; 

		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}
		return false; 

	
	}
/*-------------------------------------------------------------End Password Hashes----------------------------------------------------------- */

	//Method to move all of the Personal Information into a new table as well as encryption method for viewing the data
	/*
	 * 
	 * Function assumes the use of a Senntinel Schema 
	 *
DROP TABLE Personalinfo IF exists;
CREATE TABLE Personalinfo(
    personID INTEGER NOT NULL AUTO_INCREMENT,
    pUserID INTEGER NOT NULL, 
    Fname VARCHAR(255) NOT NULL, 
    lname varchar(255) NOT NULL, 
    StreetAddress VARCHAR(255) NOT NULL,
    States VARCHAR(255) NOT NULL, 
    zip INTEGER, 
    phonenumber varchar(255) NOT NULL, 
    email varchar(255) NOT NULL,  
    PRIMARY KEY(personID), 
    FOREIGN KEY(pUserID) REFERENCES USER(ID)
);
	 * 
	 * 
	 * */
	
	private static void PersonalInformationDB(String username)
	{	
		//Connnect to the database 
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
	    
	    //Write a query to gather all of the old PI needs to be changed to fit the datbase
	    java.sql.Statement stmt = conn.createStatement();
	    //Insert Query Results into the new table
	    
	    //Query to get some data just a mock query
	    ResultSet rs = stmt.executeQuery("SELECT fName,email from users where username = " + username); 
	    //Get the data from the query 
	    String first = rs.getString("fName");
	    String email = rs.getString("email");
	    String sql = "INSERT INTO  `eogotwa_h4hProject`.`Personalinfo` (`Username`, `fName`, "
	    				+ "`email`)" + " VALUES ('"+username+"', '"+first+"'," + "'"+email+"'+);";
	    PreparedStatement preparedInsert = conn.prepareStatement(sql);
	    
	    preparedInsert.execute(sql);
		//Insert the data into a secure table so we can encrypt and decrypt
		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}		
	}
	
	//Accessing the Perosnal information that we created in the DB
	private static ArrayList<String> AccessingPI(String username)
	{
		
		//Connnect to the database 
		ArrayList<String> data = new ArrayList<String>(); 
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
	    
	    //Write a query to gather all of the old PI needs to be changed to fit the datbase
	    java.sql.Statement stmt = conn.createStatement();
	    //Insert Query Results into the new table
	    
	    //Query to get some data just a mock query
	    ResultSet rs = stmt.executeQuery("SELECT fName,email from Personalinfo where username = " + username); 
	    //Get the data from the query 
	    String email = rs.getString("email"); 
	    String first = rs.getString("fName"); 
	    
	    data.add(email); 
	    data.add(first); 
	    
		//Insert the data into a secure table so we can encrypt and decrypt
		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}
		return data;		
	}
	
	/*-----------------------------------------Encryption-----------------------------------------*/
	//Encrypt a String
	private static byte[] encrypt(String data){
		byte enc[] = data.getBytes(); 
		byte[] newen = new byte[enc.length];
		for(int i = 0; i < enc.length; i++){
			if(i %2 == 0){
				newen[i] = (byte) (enc[i] + 1); 
			}
			else{
				newen[i] =  (byte) (enc[i] - 1); 
				
			}
			
			
		}
		return newen; 
	}
	
	//Decrypt a String
	private static byte[] decrypt(byte [] encrypted){
		byte[] newen = new byte[encrypted.length];
		for(int i = 0; i < encrypted.length; i++){
			if(i %2 == 0){
				newen[i] = (byte) (encrypted[i] - 1); 
			}
			else{
				newen[i] =  (byte) (encrypted[i] + 1); 
				
			}
			
			
		}
		return newen; 
	}
	
	
	/*-------------------------------------END ENCRYPTION-----------------------------------------------*/
	
	private static void updatehashreplace(String passTo, String username)
	{
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);

		passTo = encryptSHA256(passTo); 
		String sql = "UPDATE users SET password = '"+passTo+"' where username = '"+username+"'";
		PreparedStatement preparedInsert = conn.prepareStatement(sql);
		preparedInsert.execute(sql);
		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}
	}
	
	//Encrypt a String with 256
	public static String encryptSHA256(String needencrypt) throws NoSuchAlgorithmException
	{
		String NewHashed = ""; 
		 MessageDigest md = MessageDigest.getInstance("SHA-256");
         byte[] bytes = md.digest(needencrypt.getBytes());
         StringBuilder sb = new StringBuilder();
         for(int i=0; i< bytes.length ;i++)
         {
            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
         }
        NewHashed = sb.toString();
		return NewHashed; 
		
	}
	//Encrypt a String with SHA1
	public static String encryptSHA1(String needencrypt) throws NoSuchAlgorithmException{
		 String NewHashed = ""; 
		 MessageDigest md = MessageDigest.getInstance("SHA-1");
         byte[] bytes = md.digest(needencrypt.getBytes());
         StringBuilder sb = new StringBuilder();
         for(int i=0; i< bytes.length ;i++)
         {
            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
         }
        NewHashed = sb.toString();
		return NewHashed; 
	}
	//Encrypt a String with MD5
	public static String encryptMD5(String needencrypt) throws NoSuchAlgorithmException{
		String NewHashed = ""; 
		 MessageDigest md = MessageDigest.getInstance("MD5");
         byte[] bytes = md.digest(needencrypt.getBytes());
         StringBuilder sb = new StringBuilder();
         for(int i=0; i< bytes.length ;i++)
         {
            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
         }
        NewHashed = sb.toString();
        System.out.println(NewHashed); 
		return NewHashed; 		
	}


	
	
	
	

	
}