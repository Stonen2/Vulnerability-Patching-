package ArtOfSecurity;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;

import javax.servlet.http.HttpServletResponse;

import com.mysql.jdbc.Statement;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;


/* Created By Nick Stone on 2/2/2020
 * 
 * MODULE COMMENTS: 
 * This module is designed to be implemented by pre-existing Legacy web applications that run on JSP or other older Java Web Frameworks
 * This Package aims to resolve and defend against several security vulnerabilities and exploit attacks. 
 * 
 * We currently defend against: 
 * Contact Nick Stone to work on this open source project
 * */



public class SecurityInDetail 
{

	//List of Key words that are used in Java scriot injection attacks
    private static final String[] blockTags = {
            "html", "head", "body", "frameset", "script", "noscript", "style", "meta", "link", "title", "frame",
            "noframes", "section", "nav", "aside", "hgroup", "header", "footer", "h1", "h2", "h3", "h4", "h5", "h6",
             "pre", "div", "blockquote", "hr", "address", "figure", "figcaption", "form", "fieldset", 
            "del", "dl", "dt", "dd", "table", "caption", "thead", "tfoot", "tbody", "colgroup", "col",
            "td", "video", "audio", "canvas", "details",  "plaintext", "template", "article", 
            "svg"
    };
	//List of Key words that are used in JavaScript injection attacks
    private static final String[] inlineTags = {
            "object", "base", "font", "tt", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd",
            "var", "cite", "abbr", "time", "acronym", "mark", "ruby", "rt", "rp",  "img",  "wbr", "map",
            "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "button", "optgroup",
            "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track",
            "summary", "command", "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track",
            "data", "bdi"
    };
	//List of Key words that are used in javaScript injection attacks  
    private static final String[] emptyTags = {
            "meta", "link", "base", "frame", "img", "wbr", "embed", "hr", "input", "keygen", "command",
            "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track"
    };
  
  
    private static final String[] formSubmitTags = {
            "input", "keygen", "object", "select", "textarea"
    };
	//List of Key words that are used in SQL injection attacks, is also good to stop SQL commands inserted in queries
	private static final String[] sqlinje = {
		"select","union", "where", "or", "and", "group", "schema", "table", "alter", "as", "avg","between",
		"case","count","create","delete","group","by", "having","inner","join","outer","insert","null",
		"like","limit", "distinct", "update","with","from"
	}; 
	
	
	

	//This is a SQL Injection Prevention Method
	//Need to Document and Revisit to Refactor:
	/*This function is the sql injection prevention. This is done by taking in a String and then parsing out a series of known bad characters as well as parsing out known SQL commands */
	public static String parses(String sql) {
		//Set a string equal to the String we are sanitizing
		String aa = sql; 
		//String stringtoparse = ""; 
		//Parse out known special characters
		aa = aa.replaceAll("[@,#,$,%,^,&,*,<,>,/,',:,;',=,+,-]", "");
		//SEt the String to be all lower case
		aa.toLowerCase();
		//Parse the commands to 
		ArrayList<String> perm = new ArrayList();
		for(int i = 0; i < sqlinje.length; i++) {
				//Get all of the permutations of a given word
				perm = permutations(sqlinje[i]); 
				for(int j = 0; j < perm.size(); j++) {
					//get the word we are parsing
					String s = perm.get(j); 
					//System.out.println(s);
					//Regular expression to get rid of all of these words
					aa = aa.replaceAll(s,""); 
				}
			}
		
		
		//Parse all of the SQL commands out of the String.
		
		
		
		//Then Implement a Secure injection
		
		//System.out.println(aa); 
		//Return the sanitized String
		return aa; 
	}
	
	
	//JavaScript Injection
	/*This function is the Java script and XSS prevention script. This is done by taking in a String and then parsing out known special characters. After this the program loops through
	3 arrays that hold unique HTML and JS commands. Each command will be sent to have permutations made of each of the words and then regular expressions look for those words and replace them
	these are usually as javascript injection attacks */
	public static String parsejavascript(String sanitize) {
		//Write a Regular Expression to parse out all <Script> Tags!
		//Set a string to the string that is to be sanitized
		String bb = sanitize; 
		//Set an array 
		ArrayList<String> gs = new ArrayList<String>(); 
		//Parse all the java script tags
		//TODO Turn this into a regular expression
		
		//Block Tags Permutated
		for(int i = 0; i < blockTags.length; i++) {
			//Permute each of the words in the block tags array
			gs = permutations(blockTags[i]); 
			for(int j = 0; j < gs.size(); j++) {
				//Set a string to one of the permuted words
				String s = gs.get(j); 
				//System.out.println(s);
				//Remove this permutation from the string if found
				bb = bb.replaceAll(s,""); 
			}
		}
		//Just to make sure that <script> has  been removed
		gs = permutations("<script>"); 
		for(int j = 0; j < gs.size(); j++) {
			//String is set to a permutation of the <script> 
			String s = gs.get(j); 
			//System.out.println(s);
			//Replace all of these permutations with the regular expression
			bb = bb.replaceAll(s,""); 
		}
		//Take the permuation of the </script> 
		gs = permutations("</script>"); 
		for(int j = 0; j < gs.size(); j++) {
			//Get one of the permuated words
			String s = gs.get(j); 
			//System.out.println(s);
			//Regular expression parse out all of these from the string
			bb = bb.replaceAll(s,""); 
			
		}
		//Loop through all of the in line tags array words
		for(int i = 0; i < inlineTags.length; i++) {
			//Have the array hold the permutation of a given word
			gs = permutations(inlineTags[i]); 
			for(int j = 0; j < gs.size(); j++) {
				//Set a string to one of the words
				String s = gs.get(j); 
				//System.out.println(s);
				//Replace all of the words
				bb = bb.replaceAll(s,""); 
				
			}
		}
		//Loop through all of the empty tags array words
		for(int i = 0; i < emptyTags.length; i++) {
			//SEt an array to the permutations of one of the words
			gs = permutations(emptyTags[i]); 
			for(int j = 0; j < gs.size(); j++) {
				//Set a string to one of the words 
				String s = gs.get(j); 
				//System.out.println(s);
				//Replace all of these words from the String
				bb = bb.replaceAll(s,""); 
				
			}
		}
	//Loop through all of the form submitted tags 
	for(int i = 0; i < formSubmitTags.length; i++) {
		//Set an array to one of the permutations of the words
		gs = permutations(formSubmitTags[i]); 
		for(int j = 0; j < gs.size(); j++) {
			//String is set to one of the permuations 
			String s = gs.get(j); 
			//System.out.println(s);
			//Parse out all of the found strings
			bb = bb.replaceAll(s,""); 
			
		}
	}
		
		
		/*
		bb = bb.replaceAll("<script>", "");
		bb = bb.replaceAll("</script>", "");
		bb = bb.replaceAll("<Script>", "");
		bb = bb.replaceAll("</Script>", "");
		*/
		//Replace all special characters with a regular expression
		bb = bb.replaceAll("[@,#,$,%,^,&,*,<,>,/,',:,;']", "");
		
		
		//Return the sanitized String
		return bb; 
	}
	
	//Cookies to stop Brute Force Log In Attack
	private static void CookieLogs() {
		
		
	}
	
	//Cookies to stop Port SCan? 
	private static void portscan() {
	
	
	}
	/*The purpose of this function is to take in a given String and return all possible permutations of how the word could be entered in an array. For example suppose the String abc.Some
	Web servers will execute all JS SQL Inject commands even if weird or abnormal capitilization is placed on a given String. So given the example abc the following Strings would be put
	into an array and would be returned to the calling function. 
	abc,Abc,aBc,abC,ABc,AbC,aBC,ABC.
	*/
	 static ArrayList<String> permutations(String attack) 
	    { 
			//Set this to be all lowercase
			attack = attack.toLowerCase();  
			// Set a new array 
		 	ArrayList<String> t = new ArrayList(); 
	        //Get the length of the string
			int lengthstring = attack.length();
	        //2 ^n possible combinations
			double max = Math.pow(2, lengthstring); 
			//SEt a counter to be 0 
	        int i = 0; 
			//While i is less than the total number of combinations
	        while(i < max){
				//Set a character array to the string in questions
	            char stri[] = attack.toCharArray(); 
				//Set a counter for j 
	            int j = 0; 
				//Start another loop for the length of the word
	            while(j < lengthstring){
					//If the i bit shift right J times with a bitwise & is 1 then 
	                if(((i >> j) &  1) == 1) 
	                {
						//Set the Character to be upper case
	                    stri[j] = (char) (stri[j]-32); 
	                }
					//Increment j
	                j++; 
	            }  
	            //System.out.println(stri); 
				//Get the value of the string into a new string
	            String fsd = String.valueOf(stri); 
	            //Add the new string to the array
				t.add(fsd);   
				//Increment I 
	            i++;
				//Continue
	            continue; 
	        } 
			//Return the array with all of the words in it
	        return t; 
	    } 
	
	 
	 //On Initialization what should we do? make a cookie? 
	public static void init() {
		
		
	}
	
		//Testing
	public static void NetworkError(HttpServletResponse response) throws IOException {
		
		try {
			int s = response.getStatus(); 
			if(s > 200) {
				//Not ok
				response.sendRedirect("FileNotFound.jsp");
				//return false; 
			}
		
		}
		catch(Exception e){
			response.sendRedirect("FileNotFound.jsp");
		}
		//Ok
		//return true; 
		
		
	}
	
	//Log an entry?
	public static void Log(HttpServletResponse s)throws IOException {
		
		
		
	}
		
	//Change to SHA 256
	public static void UpdateHashAll(){
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT username, password from user"); 
		while(rs.next())
		{
			String Username = rs.getString("username"); 	 
			String unhashpassword = rs.getString("password"); 
			unhashpassword = encryptSHA256(unhashpassword); 
			//Rehash password
			//Insert back into users
			//Query to update the Query
			String sql = "UPDATE user SET password = '"+unhashpassword+"' where username = '"+Username+"'";
			PreparedStatement preparedInsert = conn.prepareStatement(sql);
			preparedInsert.execute(sql);

		}	    
		}
		catch(Exception e){
			System.out.println("An Error has occurerd"); 
			System.out.println(e); 
			
		}
		
	    
	    
		
	}
	//
	private static boolean NewAuthenitcation256(String username, String pass)
	{
	//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			return true; 

		}
		return false; 
		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}



		return false; 
	}
	
	private static boolean NewAuthenticationsha1(String username, String pass)
	{
		//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to MD5
		pass = encryptSHA1(pass); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			return true; 

		}
		return false; 

		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}




		return false; 
	}

	private static boolean NewAuthenticationmd5(String username,String pass)
	{
		//Create a Connection to the Database
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);
		java.sql.Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT password from users where username = " + username); 
		String unhash = rs.getString("password"); 
		//Hash the password to MD5
		pass = encryptMD5(pass); 
		//Hash the password to SHA256
		pass = encryptSHA256(pass); 
		//Compare this new generated hash with the hash stored in the database]
		if(pass == unhash){
			return true; 

		}
		return false; 

		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}
		return false; 

	
	}

	//Method to move all of the Personal Information into a new table as well as encryption method for viewing the data
	private static void PersonalInformationDB()
	{
		
	}
	
	//Accessing the Perosnal information that we created in the DB
	private static void AccessingPI()
	{
		
		
	}

	private static void updatehashreplace(String passTo, String username)
	{
		Connection conn;
		conn = null;
		try {
		//DB parameters
		String url       = "jdbc:mysql://127.0.0.1:3306/eogotwa_h4hProject";
		String user      = "root";
		String password  = "Infosafe1";
	   
	    //create a connection to the database
	    conn = DriverManager.getConnection(url, user, password);

		passTo = encryptSHA256(passTo); 
		String sql = "UPDATE users SET password = '"+passTo+"' where username = '"+username+"'";
		PreparedStatement preparedInsert = conn.prepareStatement(sql);
		preparedInsert.execute(sql);
		}
		catch(Exception e){
			System.out.println("THe error that was thrown is " + e); 
		}



	}
	
	//Encrypt a String with 256
	public static String encryptSHA256(String needencrypt) throws NoSuchAlgorithmException
	{
		String NewHashed = ""; 
		 MessageDigest md = MessageDigest.getInstance("SHA-256");
         byte[] bytes = md.digest(needencrypt.getBytes());
         StringBuilder sb = new StringBuilder();
         for(int i=0; i< bytes.length ;i++)
         {
            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
         }
        NewHashed = sb.toString();
		return NewHashed; 
		
	}
	//Encrypt a String with SHA1
	public static String encryptSHA1(String needencrypt) throws NoSuchAlgorithmException{
		 String NewHashed = ""; 
		 MessageDigest md = MessageDigest.getInstance("SHA-1");
         byte[] bytes = md.digest(needencrypt.getBytes());
         StringBuilder sb = new StringBuilder();
         for(int i=0; i< bytes.length ;i++)
         {
            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
         }
        NewHashed = sb.toString();
		return NewHashed; 

		
	}
	//Encrypt a String with MD5
	public static String encryptMD5(String needencrypt) throws NoSuchAlgorithmException{
		String NewHashed = ""; 
		 MessageDigest md = MessageDigest.getInstance("MD5");
         byte[] bytes = md.digest(needencrypt.getBytes());
         StringBuilder sb = new StringBuilder();
         for(int i=0; i< bytes.length ;i++)
         {
            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
         }
        NewHashed = sb.toString();
        System.out.println(NewHashed); 
		return NewHashed; 		
	}



	
}
